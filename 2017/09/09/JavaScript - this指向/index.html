<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript - this指向 · tao's blog</title><meta name="description" content="JavaScript - this指向 - Liu Tao"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="tao's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/573555508" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/taooba" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript - this指向</h1><div class="post-info">Sep 9, 2017</div><div class="post-content"><p>JavaScript 中的 <code>this</code> 的关键字相对于一般语言非常的灵活，不过无论是在<strong>全局执行环境</strong>中还是<strong>函数执行环境</strong>中，<code>this</code> 关键字的本质就是<strong>执行环境</strong>里的 <code>this</code> 变量。所以 <code>this</code> 的指向是在创建<strong>执行环境</strong>时确定的，并不是在声明定义时确定的。下面总结和归纳 <code>this</code> 在不同场景中的指向。</p>
<h1 id="全局执行环境"><a href="#全局执行环境" class="headerlink" title="全局执行环境"></a>全局执行环境</h1><p><strong>全局执行环境</strong>中 <code>this</code> 永远都指向全局本身，也就是说 <code>this</code>  == <code>window</code> == <strong>全局执行环境的变量对象</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.box_a = <span class="string">'box_a'</span>;    <span class="comment">// 通过 this 绑定到全局对象</span></div><div class="line">box_b = <span class="string">'box_b'</span>;         <span class="comment">// 通过var声明绑定到全局的变量对象上</span></div><div class="line"><span class="keyword">var</span> box_c = <span class="string">'box_c'</span>;     <span class="comment">// 通过直接赋值绑定到全局的变量对象上</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.box_a); <span class="comment">// 输出: box_a</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.box_b); <span class="comment">// 输出: box_b</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.box_c); <span class="comment">// 输出: box_c</span></div></pre></td></tr></table></figure>
<h1 id="函数执行环境"><a href="#函数执行环境" class="headerlink" title="函数执行环境"></a>函数执行环境</h1><p><strong>函数执行环境</strong>中的 <code>this</code> 指向，根据调用模式分为两种情况: <strong>方法调用模式</strong>、<strong>函数调用模式</strong>。</p>
<h3 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h3><p>当一个函数（Function）被保存为对象的一个属性时，我们称它为这个对象的方法（Method）。当一个函数以调用方法的方式调用时，其内部的 <code>this</code> 就会指向这个方法对应的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> box = <span class="string">'box_global'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.box);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj_a = &#123;<span class="attr">box</span>: <span class="string">'obj_a'</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj_b = &#123;<span class="attr">box</span>: <span class="string">'obj_b'</span>&#125;;</div><div class="line">obj_a.func = func;</div><div class="line">obj_b.func = func;</div><div class="line"></div><div class="line">obj_a.func();	<span class="comment">// 输出: &#123;box: "obj_a", func: f&#125; + obj_a</span></div><div class="line">obj_b.func();	<span class="comment">// 输出: &#123;box: "obj_b", func: f&#125; + obj_b</span></div></pre></td></tr></table></figure>
<p>上面的例子定义了一个 <code>func()</code> 函数，再把它赋值给了两个不同的对象，称为了它们的方法，再分别调用 <code>func()</code> 方法，虽然本质都是同一个函数，但是 <code>func()</code> 方法内部的 <code>this</code> 分别指向了它对应的对象 <code>obj_a</code> 和 <code>obj_b</code>。</p>
<h3 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h3><p>当一个函数并不是以对象调用方法的方式，而是直接调用函数，它就是函数调用模式。这种模式在<strong>非严格模式</strong>下函数中的 <code>this</code> 指向全局对象（在浏览器中是 <code>window</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">func();		<span class="comment">// 输出: Window&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>像下面例子中，<code>func()</code> 函数虽然是 <code>obj</code> 对象的一个方法，但是它的调用方式仍然是函数调用模式，所以 <code>func()</code> 函数内部的 <code>this</code> 指向 <code>window</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">func</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> func = obj.func;</div><div class="line">func();		<span class="comment">// 输出: Window&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>函数调用模式在<strong>严格模式</strong>下函数的中的 <code>this</code> 永远指向 <code>undefine</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">func();		<span class="comment">// 输出: undefine</span></div></pre></td></tr></table></figure>
<h1 id="new-构造函数中的-this"><a href="#new-构造函数中的-this" class="headerlink" title="new 构造函数中的 this"></a>new 构造函数中的 this</h1><p>在 JavaScript 中 <code>new</code> 关键字和函数一块使用，则我们称这个函数为构造函数。在构造函数的内部， <code>this</code> 指向新创建的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obama = <span class="keyword">new</span> Person(<span class="string">"奥观海"</span>, <span class="number">56</span>);</div><div class="line"><span class="built_in">console</span>.log(obama.name); 	<span class="comment">// 输出: 奥观海</span></div></pre></td></tr></table></figure>
<h1 id="call-apply-bind-对-this-的影响"><a href="#call-apply-bind-对-this-的影响" class="headerlink" title="call(),apply(),bind() 对 this 的影响"></a>call(),apply(),bind() 对 this 的影响</h1><p><code>call()</code> <code>apply()</code> <code>bind()</code>  这三个方法都可以让开发者改变执行函数内 <code>this</code> 的指向。</p>
<h3 id="call-apply-调用"><a href="#call-apply-调用" class="headerlink" title="call()/apply() 调用"></a>call()/apply() 调用</h3><p><code>call()</code> 和 <code>apply()</code> 这两个方法非常相似，它们的存在都是为了改变 <strong>this</strong> 的指向。它们接受的第一个参数都是执行函数内部 <code>this</code> 要指向的值。但在传递参数给执行函数时，<code>apply()</code> 是在第二个参数上接受一个参数数组，而 <code>call()</code> 则是和常规一样逐个把参数写在第二个参数 ~ 第n个参数中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj_a = &#123; <span class="attr">box</span>: <span class="string">"box_obj_a"</span> &#125;</div><div class="line"><span class="keyword">var</span> obj_b = &#123; <span class="attr">box</span>: <span class="string">"box_obj_b"</span> &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** 不传参数 */</span></div><div class="line">func.call(obj_a);           <span class="comment">// 输出: &#123;&#125; + &#123; box: 'box_obj_a' &#125;</span></div><div class="line">func.apply(obj_b);          <span class="comment">// 输出: &#123;&#125; + &#123; box: 'box_obj_b' &#125;</span></div><div class="line"></div><div class="line"><span class="comment">/** 传递参数 */</span></div><div class="line">func.call(obj_a, <span class="number">1</span>, <span class="number">2</span>);     <span class="comment">// 输出: &#123; '0': 1, '1': 2 &#125; + &#123; box: 'box_obj_a' &#125;</span></div><div class="line">func.apply(obj_b, [<span class="number">1</span>, <span class="number">2</span>]);  <span class="comment">// 输出: &#123; '0': 1, '1': 2 &#125; + &#123; box: 'box_obj_b' &#125;</span></div></pre></td></tr></table></figure>
<h3 id="bind-调用"><a href="#bind-调用" class="headerlink" title="bind() 调用"></a>bind() 调用</h3><p><code>bind()</code> 方法和 <code>call()</code> <code>apply()</code> 的区别是它可以延迟调用。调用 <code>bind()</code> 方法指定了 <code>this</code> 的指向和调用参数后会返回一个新的函数。后面再调用这个函数时它的 <code>this</code> 会指向它已绑定的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">box</span>: <span class="string">"box_obj"</span> &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** 返回一个新的函数 绑定了 this 和 参数 */</span></div><div class="line"><span class="keyword">var</span> bind_func = func.bind(obj, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">/** 后面再调用的时候仍然可以添加新参数 */</span></div><div class="line">bind_func(<span class="number">3</span>); <span class="comment">// 输出: &#123; '0': 1, '1': 2, '2': 3&#125; + &#123; box: 'box_obj' &#125;</span></div></pre></td></tr></table></figure>
<h1 id="致敬-参考内容"><a href="#致敬-参考内容" class="headerlink" title="致敬 - 参考内容"></a>致敬 - 参考内容</h1><ul>
<li><a href="https://book.douban.com/subject/3590768/" target="_blank" rel="external">《JavaScript 语言精粹》</a></li>
<li><a href="http://web.jobbole.com/83642/" target="_blank" rel="external">深入浅出妙用 Javascript 中 apply、call、bind</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/08/JavaScript - 执行环境&amp;作用域链&amp;闭包/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'tao4blog';
var disqus_identifier = '2017/09/09/JavaScript - this指向/';
var disqus_title = 'JavaScript - this指向';
var disqus_url = 'http://yoursite.com/2017/09/09/JavaScript - this指向/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//tao4blog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Liu Tao</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>