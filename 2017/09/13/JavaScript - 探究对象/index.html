<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript - 探究对象 · tao's blog</title><meta name="description" content="JavaScript - 探究对象 - Liu Tao"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="tao's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/573555508" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/taooba" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript - 探究对象</h1><div class="post-info">Sep 13, 2017</div><div class="post-content"><h1 id="初探-JavaScript-对象"><a href="#初探-JavaScript-对象" class="headerlink" title="初探 JavaScript 对象"></a>初探 JavaScript 对象</h1><p><code>JavaScript</code> 是一门面向对象语言，但和传统<strong>基于类的面向对象</strong>语言有所不同 — 它并不支持类。类就像是对象的模板，规定了某个类型的对象应该包含的属性和方法，新建对象就是根据类定义的规则生成一个对象。而 <code>JavaScript</code> 中新建对象则更像是把需要的属性和方法直接塞到一个对象中。</p>
<h3 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h3><p>基础的创建对象的方式有两种: <strong>对象字面量</strong>、<strong>new + 构造函数</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> huanghe = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"黄鹤"</span>,</div><div class="line">  <span class="attr">run</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"跑路了..."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码块使用<strong>对象字面量</strong>的方式定义了一个 <code>huanghe</code> 对象，里面包含了 <code>name</code> 属性和 <code>run</code> 方法。它和下面代码块采用<strong>new + 构造函数</strong>创建的 <code>huanghe</code> 对象内容上是完全相等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> huanghe = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">huanghe.name = <span class="string">"黄鹤"</span>;</div><div class="line">huanghe.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"跑路了..."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注:</strong> 虽然上面的例子通过<strong>对象字面量</strong>和<strong>构造函数</strong>创建的两个对象其内容是相同的，它们都具有相同的属性和方法，但实际上通过<strong>对象字面量</strong>创建对象时并不会调用 <code>Object()</code> 构造函数。</p>
</blockquote>
<h3 id="访问对象的属性"><a href="#访问对象的属性" class="headerlink" title="访问对象的属性"></a>访问对象的属性</h3><p><code>JavaScript</code> 中访问对象的属性可以通过点语法来访问，例如 <code>huanghe.name</code>。还可以通过方括号加属性名的字符串来访问，例如 <code>huanghe[&quot;name&quot;]</code>。在碰到属性名为关键字、保留字或者包含导致语法错误的字符时可以通过这种方式来访问属性。<code>JavaScript</code> 中的属性名可以为任意字符串。例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="string">"for"</span>: <span class="string">"value1"</span>,</div><div class="line">  <span class="string">"%^&amp; (*"</span>: <span class="string">"value2"</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(obj[<span class="string">"for"</span>]);    <span class="comment">// 输出: value1</span></div><div class="line"><span class="built_in">console</span>.log(obj[<span class="string">"%^&amp; (*"</span>]); <span class="comment">// 输出: value2</span></div></pre></td></tr></table></figure>
<h1 id="属性和特性"><a href="#属性和特性" class="headerlink" title="属性和特性"></a>属性和特性</h1><p><code>JavaScript</code> 对象中包含属性和方法，为了描述<strong>属性(property)</strong>的各种特征，<code>ECMA-262</code> 定义了<strong>特性(attribute)</strong>这个概念。对象<strong>属性</strong>根据它的<strong>特性</strong>的不同分为<strong>数据属性</strong>和<strong>访问器属性</strong>。</p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p><strong>数据属性</strong>一般用来存储数据，它具有以下四个<strong>特性(attribute)</strong>:</p>
<ul>
<li><strong>[[Configurable]]</strong>: 表示能否通过 <code>delete</code> 删除，能否修改属性的特性，和能否把属性修改为访问器属性。</li>
<li><strong>[[Enumerable]]</strong>: 表示能否通过 <code>for-in</code> 循环返回属性。</li>
<li><strong>[[Writable]]</strong>: 表示能否修改属性的值。 </li>
<li><strong>[[Value]]</strong>: 保存这个属性的数据值，读取/写入属性值时都是操作这个特性。 </li>
</ul>
<p><strong>数据属性</strong>可以直接在对象上定义，对象上直接定义的<strong>数据属性</strong>它们的 <code>[[Configurable]]</code> <code>[[Enumerable]]</code> <code>[[Writable]]</code> 特性都被设置为 <code>true</code>，而 <code>[[Value]]</code> 属性被设置为指定的值。例: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接在对象上定义了一个 name 数据属性</span></div><div class="line"><span class="keyword">var</span> obj  = &#123; <span class="attr">name</span>: <span class="string">"奥观海"</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">/** 使用 Object.getOwnPropertyDescriptor(对象, 属性名) 方法</span></div><div class="line"> *  查看对象的某个属性的描述符，它返回一个对象里面包含着 configurable, enumerable 等等 */</div><div class="line"><span class="keyword">var</span> attributes = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 输出: &#123; value: '奥观海', writable: true, enumerable: true, configurable: true &#125;</span></div><div class="line"><span class="built_in">console</span>.log(attributes);</div></pre></td></tr></table></figure>
<p>如果想控制属性特性的值，可以通过 <code>Object.defineProperty(对象，属性名，特性描述符)</code> 方法来定义<strong>数据属性</strong>。特性描述符对象的属性必须是 <code>configurable</code> <code>enumerable</code> <code>writable</code> <code>value</code>，设置其中的一个或多个值，可以修改对应的特性值。缺省的默认值为 <code>false</code> 。例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"name"</span>, &#123;</div><div class="line">  <span class="attr">value</span>: <span class="string">"奥观海"</span>,</div><div class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> attributes = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">"name"</span>);</div><div class="line"><span class="comment">// 输出: &#123; value: '奥观海', writable: false, enumerable: true, configurable: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(attributes);</div></pre></td></tr></table></figure>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p><strong>访问器属性</strong>不包含数据值，它包含一对可选的 <code>getter</code> 函数 和 <code>setter</code> 函数。这两个函数负责处理属性的读取和写入。<strong>访问器属性</strong>具有以下四个<strong>特性(attribute)</strong>:</p>
<ul>
<li><strong>[[Configurable]]</strong>: 表示能否通过 <code>delete</code> 删除，能否修改属性的特性，和能否把属性修改为数据属性。</li>
<li><strong>[[Enumerable]]</strong>: 表示能否通过 <code>for-in</code> 循环返回属性。</li>
<li><strong>[[Get]]</strong>: 在读取属性时调用的函数。</li>
<li><strong>[[Set]]</strong>: 在写入属性时调用的函数。</li>
</ul>
<p><strong>访问器属性</strong>不能直接在对象上定义，必须使用 <code>Object.defineProperty(对象, 属性名, 特性描述符)</code> 来定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义个对象，其中 _balance 属性表示只能通过对象方法访问(约定俗成)</span></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">_balance</span>:<span class="number">0</span>, <span class="attr">title</span>:<span class="string">"屌丝"</span>&#125;;</div><div class="line"><span class="comment">// 为对象定义一个访问器属性 balance，拥有 getter 和 setter 函数</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"balance"</span>, &#123;</div><div class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._balance; &#125;,</div><div class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>._balance = newValue;</div><div class="line">    <span class="keyword">this</span>.title = newValue &gt;= <span class="number">1000000</span> ? <span class="string">"土豪"</span> : <span class="string">"屌丝"</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/** 修改 obj.balance 访问器属性，执行其 set 函数成功影响到 title 属性。*/</span></div><div class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// 输出: &#123; _balance: 0, title: '屌丝', balance: [Getter/Setter] &#125;</span></div><div class="line">obj.balance = <span class="number">9999999</span>;</div><div class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// 输出: &#123; _balance: 9999999, title: '土豪', balance: [Getter/Setter] &#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> attributes = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">"balance"</span>);</div><div class="line"><span class="comment">// 输出: &#123;get:[Function:get], set:[Function:set], enumerable:true, configurable:false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(attributes);</div></pre></td></tr></table></figure>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>如果需要为对象一次定义多个属性并指定它的特性，可以使用  <code>Object.defineProperties(对象, 特性描述符集合)</code> 。 特性描述符集合里面可以保存任意个属性名和其对应的特性描述符。例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="comment">/** 利用 Object.defineProperties() 一次定义多个属性 */</span></div><div class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</div><div class="line">  <span class="attr">name</span>: &#123;<span class="attr">value</span>: <span class="string">"奥观海"</span>, <span class="attr">writable</span>:<span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>&#125;,</div><div class="line">  <span class="attr">title</span>: &#123;<span class="attr">value</span>: <span class="string">"屌丝"</span>, <span class="attr">writable</span>:<span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>&#125;,</div><div class="line">  <span class="attr">_balance</span>: &#123; <span class="attr">value</span>:<span class="number">0</span> &#125;,</div><div class="line">  <span class="attr">balance</span>: &#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>._balance&#125;,</div><div class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>._balance = newValue;</div><div class="line">      <span class="keyword">this</span>.title = newValue &gt;= <span class="number">1000000</span> ? <span class="string">"土豪"</span> : <span class="string">"屌丝"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(obj);	<span class="comment">// 输出: &#123; name: '奥观海', title: '屌丝' &#125;</span></div><div class="line">obj.balance = <span class="number">9999999</span>;</div><div class="line"><span class="built_in">console</span>.log(obj);	<span class="comment">// 输出: &#123; name: '奥观海', title: '土豪' &#125;</span></div></pre></td></tr></table></figure>
<h3 id="属性操作错误"><a href="#属性操作错误" class="headerlink" title="属性操作错误"></a>属性操作错误</h3><p>如果对属性执行某项操作和属性的特性有冲突，例如更改一个 <code>[[Configurable]]</code>  为 <code>false</code> 的属性特性时，或者修改一个 <code>[[Writable]]</code> 为 <code>false</code> 的属性时。在<strong>严格模式</strong>会报错，在<strong>非严格模式</strong>下会被忽略。例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"name"</span>, &#123; <span class="attr">value</span>: <span class="string">"奥观海"</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> attributes = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">"name"</span>);</div><div class="line"><span class="comment">// 输出: &#123; value: '奥观海', writable: false, enumerable: true, configurable: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(attributes);</div><div class="line"></div><div class="line">obj.name = <span class="string">"普京"</span>; <span class="comment">// 赋值无效, 被忽略</span></div><div class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// 输出: &#123; name: '奥观海' &#125;</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">  'use strict'</span></div><div class="line">  obj.name = <span class="string">"普京"</span>; <span class="comment">// 报错: Cannot assign to read only property 'name' of object</span></div><div class="line">  <span class="built_in">console</span>.log(obj);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h1 id="原型-amp-原型链"><a href="#原型-amp-原型链" class="headerlink" title="原型&amp;原型链"></a>原型&amp;原型链</h1><p>和传统<strong>基于类</strong>的<strong>面向对象</strong>语言不同，<code>JavaScript</code> 是一门<strong>基于原型</strong>的<strong>面向对象</strong>。<strong>原型</strong>其实也是对象，只不过通过一个叫做<strong>原型链</strong>的规则将一组对象串在了一块。使 <code>JavaScript</code> 拥有了类似传统语言的继承能力。下面通过一些例子和图片来解开它的面纱。</p>
<h3 id="对象中的原型-ProtoType"><a href="#对象中的原型-ProtoType" class="headerlink" title="对象中的原型: [[ProtoType]]"></a>对象中的原型: [[ProtoType]]</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"奥观海"</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">56</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj.name);		 <span class="comment">// 输出: 奥观海</span></div><div class="line"><span class="built_in">console</span>.log(obj.age);		 <span class="comment">// 输出: 56</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">// 输出: [object Object]</span></div></pre></td></tr></table></figure>
<p>上面的代码块中定义了一个 <code>obj</code> 对象，它包含了 <code>name</code> <code>age</code> 两个属性。我们可以通过 <code>obj.name</code> <code>obj.age</code> 访问到它们。但 <code>obj</code> 对象中并没有定义 <code>toString</code> 属性却也能够访问的到，这是为什么呢 ?  </p>
<p>之所以能够访问没有在 <code>obj</code> 对象中声明定义的 <code>toString</code> 属性，是因为在 <code>obj</code> 对象有一个隐藏的内部属性 <code>[[Prototype]]</code>，指向 <code>obj</code> 对象的原型对象，这个原型对象拥有 <code>toString</code> 属性。原型对象也是一个对象，有可能它的 <code>[[Prototype]]</code> 属性还会指向另一个原型对象，这样就形成了一个叫做<strong>原型链</strong>的链条。最后一个原型对象的 <code>[[Prototype]]</code> 属性会指向 <code>null</code>。 </p>
<p>每次访问一个对象的属性，JS 引擎都会根据属性名执行一次搜索。搜索会先从在当前对象上查找是否包含这个属性，如果没有则去查找这个对象的<strong>原型对象</strong>上是否包含这个属性，一直沿着<strong>原型链</strong>往上找，如果到了<strong>原型链</strong>最顶端也没有找到则会返回 <code>undefined</code> 。</p>
<blockquote>
<p><strong>通过 <code>__proto__</code> 属性访问内部属性 <code>[[Prototype]]</code> </strong></p>
<p><code>[[Prototype]]</code> 是一个隐藏的内部属性，它指向对象的原型对象。开发人员并不能直接访问 <code>[[Prototype]]</code>，但是 JS 引擎在内部会使用到这个属性。不过很多宿主环境都实现了一个非标准的 <code>__proto__</code> 属性，它和 <code>[[Prototype]]</code> 的作用相同也是指向对象的<strong>原型对象</strong>。</p>
</blockquote>
<h3 id="函数中的原型-prototype"><a href="#函数中的原型-prototype" class="headerlink" title="函数中的原型: prototype"></a>函数中的原型: prototype</h3><p>在 <code>JavaScript</code> 中函数也是对象，所以函数也有拥有指向<strong>原型对象</strong>的隐藏属性 <code>[[Prototype]]</code>，在支持 <code>__proto__</code> 的<strong>宿主环境</strong>里可以通过 <code>__proto__</code> 属性访问到它<strong>原型对象</strong>。不过 <code>JavaScript</code> 的函数对象还拥有一个属性也叫 <code>prototype</code>，它并不是隐藏属性。虽然这两个属性名字很相似，指向的也都是<strong>原型对象</strong>，但是他们作用是完全不同的，绝大部分的时候它们指向的是不同的对象。 例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义了一个构造函数 Person()</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(Person.prototype);	<span class="comment">// 输出: Person &#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(Person.__proto__);	<span class="comment">// 输出: [Function]</span></div><div class="line"><span class="comment">/** Person 函数的 prototype 和 __proto__ 并不指向同一个对象 */</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype === Person.__proto__);	<span class="comment">// 输出: false</span></div></pre></td></tr></table></figure>
<p><code>JavaScript</code> 中可以使用<strong>new + 构造函数</strong>去创建一个新对象，<strong>构造函数</strong>和普通函数并无差别，只是约定俗称把<strong>构造函数</strong>的名称第一个字母大写。<strong>new + 构造函数</strong>创建的对象的 <code>[[Prototype]]</code> 隐藏属性和 <strong>构造函数</strong>的 <code>prototype</code> 属性指向的是同一个<strong>原型对象</strong>。并且这个<strong>原型对象</strong>有一个 <code>constructor</code>  属性指向对应<strong>构造函数</strong>。</p>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name,</div><div class="line">  <span class="keyword">this</span>.age = age</div><div class="line">&#125;</div><div class="line">Person.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"在跑..."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> zhaosi = <span class="keyword">new</span> Person(<span class="string">"赵四"</span>, <span class="number">57</span>);</div><div class="line"><span class="keyword">var</span> obama = <span class="keyword">new</span> Person(<span class="string">"奥观海"</span>, <span class="number">56</span>);</div><div class="line"><span class="built_in">console</span>.log(zhaosi.__proto__ === obama.__proto__);    <span class="comment">// 输出: true</span></div><div class="line"><span class="built_in">console</span>.log(zhaosi.run === obama.run);                <span class="comment">// 输出: true</span></div><div class="line">obama.run();      <span class="comment">// 输出: 奥观海在跑...</span></div><div class="line">zhaosi.run(); 	  <span class="comment">// 输出: 赵四在跑...</span></div><div class="line"><span class="built_in">console</span>.log(obama.__proto__ === Person.prototype); 		<span class="comment">// 输出: true</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person);	<span class="comment">// 输出: true</span></div></pre></td></tr></table></figure>
<p>上面的代码块定义了一个 <code>Person</code> <strong>构造函数</strong>，并利用这个<strong>构造函数</strong>创建了两个对象 <code>zhaosi</code> <code>obama</code>。这两个对象的 <code>[[Prototype]]</code> 指向同一个<strong>原型对象</strong>，所以<strong>原型对象</strong>中的 <code>run</code> 方法也是同一个，但是因为方法中引用了不同的实例属性导致输出内容不同。</p>
<p>把 <code>obama</code> 对象的原型和 <code>Person</code> 函数的原型进行对比，证实了对象的 <code>[[Prototype]]</code> 和对应的<strong>构造函数</strong>指向的是同一个<strong>原型对象</strong>，并且这个<strong>原型对象</strong>还有一个 <code>constructor</code> 对象指向 <code>Person</code> 函数。下面的图片展示的上面代码块执行完，整个对象的原型链:</p>
<p><img src="/Users/taooba/Desktop/javascript_prototype_chain.png" alt="javascript_prototype_chain"></p>
<p>除去 <code>Function</code> 函数和 <code>Function</code> 原型对象的指向箭头不看，整个原型链还是非常清晰的。<code>obama</code> <code>zhaosi</code> 都是通过 <code>new</code> + <code>Person</code> <strong>构造函数</strong>创建出来的，所以它们的 <code>[[Prototype]]</code> 都指向 <code>Person</code> 原型对象。 <code>Person</code> 原型对象其实是一个 <code>Object</code>类型的对象，所以它的 <code>[[Prototype]]</code> 指向的是 <code>Object</code> 原型对象。<code>Object</code> 原型对象位于这条<strong>原型链</strong>的最末端，所以它的 <code>[[Prototype]]</code> 指向 <code>null</code>。</p>
<p><code>Function</code> 函数这里很绕人，因为所以的函数都是 <code>Function</code> <strong>构造函数</strong>的示例，所以 <code>Function</code> <strong>构造函数</strong>的 <code>prototype</code> 和所有的函数的 <code>[[Prototype]]</code> 指向的都是 <code>Function</code> 原型对象。但是 <code>Function</code> <strong>构造函数</strong>也是一个函数。所以它的 <code>[[Prototype]]</code> 也指向 <code>Function</code> 原型对象。这就是一个鸡生蛋和蛋生鸡的问题。不过不不用纠结， <code>Function</code> 函数是系统提供一个对象。不用开发人员去操心。只是说明一下它的特殊性。上面说过函数里的 <code>[[Prototype]]</code> 和 <code>prototype</code> 虽然指向的都是<strong>原型对象</strong>，但是他们绝大部分的时候指向的都是不同的对象。 <code>Function</code> 就是这个唯一的例外。</p>
<h1 id="识别对象的方法"><a href="#识别对象的方法" class="headerlink" title="识别对象的方法"></a>识别对象的方法</h1><h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p><code>typeof</code> 是一个一元操作符，它返回它的操作值的类型的字符串。<code>typeof</code> 一般只会返回如下几个结果:</p>
<p><code>number</code> <code>boolean</code> <code>string</code> <code>function</code> <code>object</code> <code>undefined</code>。 例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);      <span class="comment">// 输出: number</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);   <span class="comment">// 输出: boolean</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"str"</span>);  <span class="comment">// 输出: string</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">// 输出: function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);   <span class="comment">// 输出: object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);     <span class="comment">// 输出: object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);     <span class="comment">// 输出: object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> box);    <span class="comment">// 输出: undefined</span></div></pre></td></tr></table></figure>
<p>在开发中访问未声明的变量会导致错误，此时可以先使用 <code>typeof</code> 去判断变量是否存在，如果不存在它会返回 <code>undefined</code> 字符串。<code>typeof</code> 对函数返回的是 <code>function</code>，对另外所有的对象都会返回 <code>object</code>， <code>typeof null</code> 返回的也是 <code>object</code>。如果需要很细致的判断是什么类型的对象 <code>typeof</code> 就会显得力不从心，<code>instanceof</code> 是个更好的选择。</p>
<h3 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h3><p><code>instanceof</code> 是一个二元运算符，它判断一个对象是否是某个类型的对象，是的话返回 <code>true</code>。<code>instanceof</code> 操作符本质上就是判断一个对象的<strong>原型链</strong>上是否存在对应的<strong>构造函数</strong>的 <code>prototype</code>  属性。例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123; <span class="keyword">this</span>.name = name; &#125;;</div><div class="line"><span class="keyword">var</span> obama = <span class="keyword">new</span> Person(<span class="string">"奥观海"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obama <span class="keyword">instanceof</span> Person); <span class="comment">// 输出: true</span></div><div class="line"><span class="comment">/** 因为 Person 继承自 Object 所以 obama 也是 Object 类型*/</span></div><div class="line"><span class="built_in">console</span>.log(obama <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// 输出: true</span></div><div class="line"><span class="built_in">console</span>.log(obama <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">// 输出: false</span></div></pre></td></tr></table></figure>
<h3 id="判断对象的原型对象"><a href="#判断对象的原型对象" class="headerlink" title="判断对象的原型对象"></a>判断对象的原型对象</h3><p><code>Object.isPrototypeOf()</code> 方法可以判断当前调用者对象是否存在于传入对象的原型链上。例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1)); <span class="comment">// 输出: true</span></div><div class="line"><span class="comment">/** 这句话返回 true， 是因为 Object。prototype 位于 person1 对象的原型上 */</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(person1)); <span class="comment">// 输出: true</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(obj1));	  <span class="comment">// 输出: false</span></div></pre></td></tr></table></figure>
<h3 id="访问对象的原型对象"><a href="#访问对象的原型对象" class="headerlink" title="访问对象的原型对象"></a>访问对象的原型对象</h3><p>ES5 新增了一个 <code>Object.getPrototypeOf()</code> 方法，它能够返回对象隐藏属性 <code>[[Prototype]]</code> 的值。 例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123; <span class="keyword">this</span>.name = name; &#125;;</div><div class="line">Person.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"跑了..."</span>)&#125;;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="keyword">var</span> prototype = <span class="built_in">Object</span>.getPrototypeOf(person1);</div><div class="line"><span class="built_in">console</span>.log(prototype === Person.prototype); <span class="comment">// 输出: true</span></div><div class="line"><span class="built_in">console</span>.log(prototype.run);					 <span class="comment">// 输出: [Function]</span></div></pre></td></tr></table></figure>
<h3 id="判断属性存在于实例中还是原型中"><a href="#判断属性存在于实例中还是原型中" class="headerlink" title="判断属性存在于实例中还是原型中"></a>判断属性存在于实例中还是原型中</h3><p><code>Object</code> 原型对象中有一个 <code>hasOwnProperty()</code> 方法，任何继承自 <code>Object</code> 原型对象的对象都可以调用。它会判断传入的属性名是否是当前实例的属性，如果是返回 <code>true</code>。如果是原型对象中的属性则返回 <code>false</code>。 例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"跑了..."</span>);&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"奥观海"</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>));	<span class="comment">// 输出: true</span></div><div class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"run"</span>));		<span class="comment">// 输出: false</span></div><div class="line">person1.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"run"</span>));		<span class="comment">// 输出: true</span></div></pre></td></tr></table></figure>
<p><code>JavaScript</code> 中的 <code>in</code> 关键字除了可以进行 <code>for-in</code> 循环，单独使用时还能判断一个对象能否访问给定的属性，可以访问返回 <code>true</code> 。结合 <code>hasOwnProperty()</code> 和 <code>in</code> 关键字，则可以判断对象的一个属性是否是在原型对象中。例子: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Object.keys() 要取得对象上所有可枚举的实例属性</p>
<p>如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法</p>
<p>属性屏蔽</p>
<p>原型的动态性</p>
<p>Object.create();</p>
<h1 id="致敬-参考内容"><a href="#致敬-参考内容" class="headerlink" title="致敬 - 参考内容"></a>致敬 - 参考内容</h1><ul>
<li><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="external">《JavaScript 高级程序设计》</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/11/JavaScript - 函数重载/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'tao4blog';
var disqus_identifier = '2017/09/13/JavaScript - 探究对象/';
var disqus_title = 'JavaScript - 探究对象';
var disqus_url = 'http://yoursite.com/2017/09/13/JavaScript - 探究对象/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//tao4blog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Liu Tao</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>