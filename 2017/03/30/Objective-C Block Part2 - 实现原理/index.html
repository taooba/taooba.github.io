<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Objective-C Block Part2 - 实现原理 · tao's blog</title><meta name="description" content="Objective-C Block Part2 - 实现原理 - Liu Tao"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="tao's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/573555508" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/taooba" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Objective-C Block Part2 - 实现原理</h1><div class="post-info">Mar 30, 2017</div><div class="post-content"><h2 id="Block-的本质"><a href="#Block-的本质" class="headerlink" title="Block 的本质"></a>Block 的本质</h2><p>在 <strong><a href="http://tao.bio/2017/03/26/Objective-C%20Block%20Part1%20-%20%E4%BB%8B%E7%BB%8D&amp;%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">Objective-C Block Part1</a></strong>  中总结了 Block 的一些使用规则，但是为什么要遵循这些规则，还有这些规则是怎么来的？ 这就需要探寻 Block 的本质，明白它的实现原理。</p>
<blockquote>
<p><strong>注:</strong>  我们通过 clang 把包含 Block 的 Objective-C 的代码转换成 C++ 实现代码，以此来分析 Block 的实现原理。通过 clang 重写的代码仅供我们分析和参考，在极少数地方和实际运行时有细微出入。</p>
</blockquote>
<p><br></p>
<h4 id="简单-Block-转换后的代码分析"><a href="#简单-Block-转换后的代码分析" class="headerlink" title="简单 Block 转换后的代码分析"></a>简单 Block 转换后的代码分析</h4><p>下面通过 <code>clang -rewrite-objc main.m</code> 把一个简单的 Block 转换成 C++ 代码 <code>main.cpp</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/** 转换前的 Objective-C 代码: */</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    char *name = &quot;Steve Jobs&quot;;</div><div class="line">    ^() &#123;</div><div class="line">        printf(&quot;hello %s :)&quot;, name);</div><div class="line">    &#125;();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 转换后裁剪出的重要代码: */</span></div><div class="line"><span class="keyword">struct</span> __block_impl &#123;</div><div class="line">    <span class="keyword">void</span> *isa;</div><div class="line">    <span class="keyword">int</span> Flags;</div><div class="line">    <span class="keyword">int</span> Reserved;</div><div class="line">    <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  <span class="keyword">char</span> *name;</div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">char</span> *_name, <span class="keyword">int</span> flags=<span class="number">0</span>) : name(_name) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="keyword">char</span> *name = __cself-&gt;name; <span class="comment">// bound by copy</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"hello %s :)"</span>, name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  <span class="keyword">size_t</span> reserved;</div><div class="line">  <span class="keyword">size_t</span> Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> *name = <span class="string">"Steve Jobs"</span>;</div><div class="line">    ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, name))();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>我们看到 Block 的本质其实就是一个名为 <code>__main_block_impl_0</code> 的结构体。这个结构体包含的主要内容:</strong> </p>
<ol>
<li><code>__block_impl</code> 结构体的变量。 (block 结构体的第一个成员都是 <code>__block_impl</code>, 所以 <code>__block_impl</code> 是 block 的基础结构体。</li>
<li><code>__main_block_desc_0</code> 结构体的变量。( <code>__main_block_desc_0</code> 是描述 block 的结构体。</li>
<li><strong>可选的</strong> 被截获的成员，例如本例的 <code>char *name</code> ，这一块下一节细述。</li>
<li><code>__main_block_impl_0</code> 结构体的构造函数</li>
</ol>
<p><br></p>
<p><strong>再来分析一下 <code>__main_block_impl_0</code> 结构体的第一个成员 <code>__block_impl</code> 结构体里的内容:</strong></p>
<ol>
<li><code>void *isa;</code>  (所有的 OC 对象的都有 isa指针，这也说明 Block 是一个 OC 对象。</li>
<li><code>int Flags;</code>  (用于按 bit 位表示一些 block 的附加信息。</li>
<li><code>int Reserved;</code>  (保留变量。</li>
<li><code>void *FuncPtr;</code>  (block 执行的函数指针，这个函数指针包含的是 OC 里面写在 Block 里面的代码。</li>
</ol>
<p><br></p>
<p><strong><code>__main_block_desc_0</code> 的内容:</strong></p>
<ol>
<li><code>size_t reserved;</code>  (保留变量</li>
<li><code>size_t Block_size;</code>  (保存 Block 的大小</li>
</ol>
<p><br></p>
<h2 id="Block-截获变量"><a href="#Block-截获变量" class="headerlink" title="Block 截获变量"></a>Block 截获变量</h2><p>上面一节大概了解了 Block 是个什么东西，这一节则会进行更深入的探索，搞清楚 Block 对各种类型的变量在内部是如何处理。下面通过 clang 转换一个包含各种变量的 Block 来分析这些问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/** 转换前的 Objective-C 代码(ARC): */</div><div class="line">typedef void(^blk_t)();</div><div class="line"></div><div class="line">static int static_global_val = 1;       // 静态全局变量(C</div><div class="line">static NSObject *static_global_obj;     // 静态全局变量(OC</div><div class="line">int global_val = 1;                     // 全局变量(C</div><div class="line">NSObject *global_obj;                   // 全局变量(OC</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    int automatic_val = 1;                                   // 自动变量(C</div><div class="line">    NSObject *automatic_obj = [NSObject new];      		    // 自动变量(OC</div><div class="line">    </div><div class="line">    __block int __block_val = 1;                             // __block变量(C</div><div class="line">    __block NSObject *__block_obj = [NSObject new]; 		// __block变量(OC</div><div class="line">    </div><div class="line">    static int static_val = 1;                               // 静态变量(C</div><div class="line">    static NSObject *static_obj;                             // 静态变量(OC</div><div class="line">    </div><div class="line">    static_global_obj = [NSObject new];</div><div class="line">    global_obj = [NSObject new];</div><div class="line">    static_obj = [NSObject new];</div><div class="line">    </div><div class="line">    blk_t block = ^&#123;</div><div class="line">      static_global_val = 1;</div><div class="line">      static_global_obj = [NSArray array];</div><div class="line">      global_val = 1;</div><div class="line">      global_obj = [NSArray array];  </div><div class="line">      static_val = 1;</div><div class="line">      static_obj = [NSArray array];</div><div class="line">        </div><div class="line">      __block_val = 1;</div><div class="line">      __block_obj = [NSArray array];</div><div class="line">      printf(&quot;%d,%p&quot;, automatic_val, automatic_obj);</div><div class="line">      //automatic_val = 1; 			    // 报错</div><div class="line">      //automatic_obj = [NSArray array]; // 报错</div><div class="line">    &#125;;</div><div class="line">    block();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<p>下面是转换成 C++ 的代码， 其中裁剪出重要的内容来显示，代码后面是分析上面问题的答案:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">/** 转换后的C++代码(ARC): */</div><div class="line">typedef void(*blk_t)();</div><div class="line"></div><div class="line">static int static_global_val = 1;</div><div class="line">static NSObject *static_global_obj;</div><div class="line">int global_val = 1;</div><div class="line">NSObject *global_obj;</div><div class="line"></div><div class="line">struct __Block_byref___block_val_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">  __Block_byref___block_val_0 *__forwarding;</div><div class="line">  int __flags;</div><div class="line">  int __size;</div><div class="line">  int __block_val;</div><div class="line">&#125;;</div><div class="line">struct __Block_byref___block_obj_1 &#123;</div><div class="line">  void *__isa;</div><div class="line">  __Block_byref___block_obj_1 *__forwarding;</div><div class="line">  int __flags;</div><div class="line">  int __size;</div><div class="line">  void (*__Block_byref_id_object_copy)(void*, void*);</div><div class="line">  void (*__Block_byref_id_object_dispose)(void*);</div><div class="line">  NSObject *__block_obj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int *static_val;</div><div class="line">  NSObject **static_obj;</div><div class="line">  int automatic_val;</div><div class="line">  NSObject *automatic_obj;</div><div class="line">  __Block_byref___block_val_0 *__block_val; // by ref</div><div class="line">  __Block_byref___block_obj_1 *__block_obj; // by ref</div><div class="line">  </div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, NSObject **_static_obj, int _automatic_val, NSObject *_automatic_obj, __Block_byref___block_val_0 *___block_val, __Block_byref___block_obj_1 *___block_obj, int flags=0) : static_val(_static_val), static_obj(_static_obj), automatic_val(_automatic_val), automatic_obj(_automatic_obj), __block_val(___block_val-&gt;__forwarding), __block_obj(___block_obj-&gt;__forwarding) &#123; </div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">    size_t reserved;</div><div class="line">    size_t Block_size;</div><div class="line">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123;0,sizeof(struct __main_block_impl_0),__main_block_copy_0,__main_block_dispose_0&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref___block_val_0 *__block_val = __cself-&gt;__block_val; // bound by ref</div><div class="line">  __Block_byref___block_obj_1 *__block_obj = __cself-&gt;__block_obj; // bound by ref</div><div class="line">  int *static_val = __cself-&gt;static_val;	   // bound by copy</div><div class="line">  NSObject **static_obj = __cself-&gt;static_obj; // bound by copy</div><div class="line"></div><div class="line">    static_global_val = 1;</div><div class="line">    static_global_obj = objc_msgSend(objc_getClass(&quot;NSArray&quot;), sel_registerName(&quot;array&quot;));</div><div class="line">    global_val = 1;</div><div class="line">    global_obj = objc_msgSend(objc_getClass(&quot;NSArray&quot;), sel_registerName(&quot;array&quot;));</div><div class="line"></div><div class="line">    (*static_val) = 1;</div><div class="line">    (*static_obj) = objc_msgSend(objc_getClass(&quot;NSArray&quot;), sel_registerName(&quot;array&quot;));</div><div class="line">    (__block_val-&gt;__forwarding-&gt;__block_val) = 1;</div><div class="line">    (__block_obj-&gt;__forwarding-&gt;__block_obj) = objc_msgSend(objc_getClass(&quot;NSArray&quot;), sel_registerName(&quot;new&quot;));</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src&#123;...&#125;</div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;...&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    int automatic_val = 1;</div><div class="line">    NSObject *automatic_obj = objc_msgSend((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;));</div><div class="line">  </div><div class="line">    __Block_byref___block_val_0 __block_val = &#123;(void*)0,&amp;__block_val,0,sizeof(__Block_byref___block_val_0),1&#125;;</div><div class="line">    __Block_byref___block_obj_1 __block_obj = &#123;(void*)0, &amp;__block_obj, 33554432, sizeof(__Block_byref___block_obj_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, objc_msgSend(objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;))&#125;;</div><div class="line"></div><div class="line">    static int static_val = 1;</div><div class="line">    static NSObject *static_obj;</div><div class="line"></div><div class="line">    static_global_obj = objc_msgSend(objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;));</div><div class="line">    global_obj = objc_msgSend(objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;));</div><div class="line">    static_obj = objc_msgSend(objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;));</div><div class="line">    </div><div class="line">    blk_t block = ((void (*)())&amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val, &amp;static_obj, automatic_val, automatic_obj, &amp;__block_val, &amp;__block_obj, 570425344));</div><div class="line">  </div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-Block-怎么处理自动变量"><a href="#1-Block-怎么处理自动变量" class="headerlink" title="1. Block 怎么处理自动变量?"></a>1. Block 怎么处理自动变量?</h4><p>从上面的  C++ 代码中可以看出，在 Block 对应的 <code>__main_block_impl_0</code> struct 中有和自动变量 <code>automatic_val</code> <code>automatic_obj</code>  相同的类型的结构体成员。 <code>__main_block_impl_0</code>  struct 的构造方法 <code>__main_block_impl_0</code> 的参数中也会接受 <code>automatic_val</code> <code>automatic_obj</code> 同类型的参数，然后把其赋值给对应的 strcut 成员。 可以看下在 <code>main</code> 函数中对 <code>__main_block_impl_0</code> 构造函数的调用。 这里有几个值得注意的点: </p>
<ol>
<li><p>对于 <code>C 基础类型</code>  <code>automatic_val</code> 直接传递的是值 <code>1</code> , 所以 mian 函数中定义的 <code>int automatic_val</code>  和 Block 对应结构体中的 <code>automatic_val</code>  结构体成员不是同一个变量。通过下面的小例子可以证明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">  int automatic_val = 1;</div><div class="line">  blk_t block = ^ &#123; printf(&quot;inside  in room val:%d \n&quot;,automatic_val);&#125;;</div><div class="line">  automatic_val = 2;</div><div class="line">  printf(&quot;outside in room val:%d \n&quot;,automatic_val);</div><div class="line">  </div><div class="line">  block();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是上面代码的输出，可以看到在 Block 外改变 val 的值根本影响不到 Block 内的值，因为他们不在同一块内存上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">outside in room val:2 </div><div class="line">inside  in room val:1</div></pre></td></tr></table></figure>
</li>
<li><p>对于 <code>OC 对象类型</code> <code>automatic_obj</code> 是直接传递指针，和 <code>automatic_val</code> 同理，如果在 Block  外新建一个 <code>OC 对象类型</code> 的指针，再赋值给 <code>automatic_obj</code> 变量也对 Block 内的 <code>automatic_obj</code> 结构体成员是没有影响的，因为这两个变量里面此时装的已经是不同的指针了。 但是当它们装的是同一个指针时，是可以通过调用对象的方法来相互影响的， 举个栗子，在 Block 外更改可变数组里的内容是会影响到 Block 内部的可变数组的，因为此时这两个变量是装的同一个指针:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    NSMutableArray *automatic_obj = [NSMutableArray arrayWithObjects:@&quot;1&quot;, @&quot;2&quot;, nil];</div><div class="line">    blk_t block = ^ &#123;</div><div class="line">        NSLog(@&quot;inside  in room obj: %@&quot;, automatic_obj);</div><div class="line">    &#125;;</div><div class="line">    [automatic_obj addObject:@&quot;3&quot;];</div><div class="line">    NSLog(@&quot;outside in room obj: %@&quot;, automatic_obj);</div><div class="line">  </div><div class="line">    block();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在  Block 对应的 <code>__main_block_impl_0</code> struct 中，修饰 <code>automatic_obj</code> 的是 strong 所有权修饰符，所以 Block 会对这个对象进行持有， 为什么系统这么去设计让 Block 持有自动变量? 是因为 Block 能够超出其所在的函数作用域存在，而 <code>OC 对象类型</code> 的自动变量在超出函数作用域时就会被释放被释放，Block 此时执行时这个对象已经被销毁了。为了避免这种情况 Block 持有了 <code>OC 对象类型</code> 的自动变量。</p>
</li>
</ol>
<p><br></p>
<h4 id="2-Block-怎么处理-静态全局变量-全局变量-静态变量"><a href="#2-Block-怎么处理-静态全局变量-全局变量-静态变量" class="headerlink" title="2. Block 怎么处理 静态全局变量 / 全局变量 / 静态变量 ?"></a>2. Block 怎么处理 静态全局变量 / 全局变量 / 静态变量 ?</h4><p>之所以把这三种变量归纳到一起，是因为它们的生命周期在一个程序中会一直存在。 Block 中使用 <code>静态全局变量</code> 和 <code>全局变量</code> 时，因为它们的作用域是全局的，并且是在程序中一直存在的，所以转换后这部分没有任何变化可以直接使用，并且可以在 Block 中重新赋值。 Block 中使用 <code>静态变量</code> 转换后会在 Block 对应的 <code>__main_block_impl_0</code> struct 中追加这个 <code>静态变量</code> 的类型的指针，然后通过 strcut 的构造函数传递进去，通过这种方式扩大了这个静态变量可访问的作用域， 使其可以在 <code>__main_block_func_0</code> 函数中访问。同时也因为传递的是 <code>静态变量</code> 类型的指针所以具备了重新赋值的能力。 </p>
<p><br></p>
<h4 id="3-Block-怎么处理-block-修饰的自动变量"><a href="#3-Block-怎么处理-block-修饰的自动变量" class="headerlink" title="3. Block 怎么处理 __block 修饰的自动变量 ?"></a>3. Block 怎么处理 __block 修饰的自动变量 ?</h4><p>上面的例子中 <code>__block</code> 修饰的自动变量 <code>__block_val</code> <code>__block_obj</code>  在转换后分别变成了 <code>__Block_byref___block_val_0</code>  和<code>__Block_byref___block_val_1</code>  结构体，并且它们第一个成员都是 <code>isa 指针</code>，这说明它们都是 OC 对象。第二个成员是 <code>__forwarding 指针</code> 目前是指向这个结构体的本身。 这两个结构体分别还包含着对应的 <code>__block</code> 自动变量类型的 结构体成员。</p>
<p><br></p>
<h2 id="Block-的储存域"><a href="#Block-的储存域" class="headerlink" title="Block 的储存域"></a>Block 的储存域</h2><p>因为 Block 对应的结构体第一个成员是 <code>isa 指针</code> ，所以 Block 也是个 <code>OC 对象</code> ，那么 <code>isa 指针</code> 指向的就是 Block 的类了。以前我们接触到的都是 <code>_NSConcreteStackBlock</code> ，其实还有另外两种: <code>_NSConcreteGlobalBlock</code> <code>_NSConcreteMallocBlock</code> 。 这一节就是来探讨这三种 Block 的不同和作用。</p>
<p><br></p>
<h4 id="三种-Block-在内存的存储区域"><a href="#三种-Block-在内存的存储区域" class="headerlink" title="三种 Block 在内存的存储区域"></a>三种 Block 在内存的存储区域</h4><ul>
<li><code>_NSConcreteStackBlock</code> 类的 Block 对象是设置栈区上的，超出其所在的函数作用域就会被释放。</li>
<li><code>_NSConcreteGlobalBlock</code> 类的 Block 对象是设置在 .data 区上，在程序运行时永久存在的。</li>
<li><code>_NSConcreteMallocBlock</code> 类的 Block 对象是设置在堆区上。</li>
</ul>
<h4 id="怎么区分这三种-Block"><a href="#怎么区分这三种-Block" class="headerlink" title="怎么区分这三种 Block"></a>怎么区分这三种 Block</h4><p><strong>_NSConcreteGlobalBlock</strong> </p>
<ul>
<li>在所有方法外定义的 Block 为 <code>Global Block</code></li>
<li>当 Block 中没有截获自动变量是为 <code>Global Block</code></li>
</ul>
<p><strong>_NSConcreteMallocBlock</strong> </p>
<p><code>Malloc Block</code> 是 <code>Stack Block</code> 被执行 copy 操作后得到的。它能让 Block 超出函数/方法的作用域而存在。</p>
<p><strong>_NSConcreteStackBlock</strong>  </p>
<p>除了上面的情况，剩下的就都是 <code>Stack Block</code> 了。当其所在的函数作用域结束时，这个 Block 就会被回收。</p>
<p><br></p>
<h4 id="那些情况系统会自动帮你调用-copy-方法"><a href="#那些情况系统会自动帮你调用-copy-方法" class="headerlink" title="那些情况系统会自动帮你调用 copy 方法"></a>那些情况系统会自动帮你调用 copy 方法</h4><p>通过 copy 操作可以让 <code>Stack Block</code> 拷贝成 <code>Malloc Block</code>，但是在一些情况下，系统会自动的帮我们执行 copy 操作:</p>
<ul>
<li><code>ARC</code> Block 作为函数返回值返回时会自动对 Block 执行 copy 操作。</li>
<li><code>ARC</code> 下将 Block 赋值给附有 <code>__strong</code>  修饰符的变量时。 所以在 <code>ARC</code> 下不用调用 copy 操作，直接把它赋值给 <code>__strong</code> 变量就可以达到效果，还有对于 Block 类型的 @property 的 attribute 不用写 copy。直接使用默认的 <code>__strong</code> ，有太多人在 <code>ARC</code> 下还是用 copy 去修饰。 完全没有必要</li>
<li>在方法名中含有 usingBlock 的 Cocoa 框架方法或 Grand Central Dispatch 的 API 中传递 Block 时。</li>
</ul>
<p><br></p>
<h4 id="Block-copy-时会发生什么-会造成什么影响"><a href="#Block-copy-时会发生什么-会造成什么影响" class="headerlink" title="Block copy 时会发生什么? 会造成什么影响?"></a>Block copy 时会发生什么? 会造成什么影响?</h4><p>大部分的 Block 对象是设置在栈内存上的，为了使 Block 能够超出其函数作用域的范围。可以使用 copy 操作将其从栈内存拷贝到堆内存中。对于 Block 中的 <code>__block</code> 变量一开始它也是配置在栈内存中的，在超出函数作用域时它也会被释放。所以在拷贝 Block 对象到堆内存中时，也会同时拷贝这个 Block 使用的 <code>__block</code> 变量到堆内存中。 当多个 Block 对象同时使用一个 <code>__block</code> 变量时，如果其中有个 Block 已经把 <code>__block</code> 变量拷贝到堆内存上了。后面的 Block 再次对这个 <code>__block</code> 变量执行 copy 操作时只会增加这个  <code>__block</code> 变量的持有。 等 Block 销毁时就会减少 <code>__block</code> 变量的持有。当没有 Block 持有 <code>__block</code> 变量时它就会被回收。这和我们一直使用的引用计数的内存管理方式相同。</p>
<p><br></p>
<h4 id="为什么要设计-forwarding-这个东西"><a href="#为什么要设计-forwarding-这个东西" class="headerlink" title="为什么要设计 __forwarding 这个东西?"></a>为什么要设计 __forwarding 这个东西?</h4><p>上一节的例子中 <code>__block_val</code> <code>__block_obj</code> 这两个 <code>__block</code> 变量在被转换后，分别变成了 <code>__Block_byref___block_val_0</code> <code>__Block_byref___block_val_1</code> 结构体，并且结构体的第二个成员都是 <code>__forwarding</code> 指针。 这个 <code>__forwarding</code> 指针目前是指向自己的。为什么要去设计 <code>__forwarding</code> 指针这个东西？这需要刚才讨论的 Block 对象的拷贝结合在一起看。</p>
<p><code>__forwarding</code> 指针存在的意义是不管 <code>__block</code> 变量是配置在栈上还是堆上，都能够正确的访问变量。当 Block 对象被拷贝到堆内存中是， <code>__block</code> 变量也被拷贝到堆内存中。那么此时可以同时访问栈上的 <code>__block</code> 变量 和 堆上的 <code>__block</code> 变量。他们都是通过下面的方式访问的， 都是通过 <code>__forarding</code> 指针: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__block_val-&gt;__forwarding-&gt;__block_val</div><div class="line">__block_obj-&gt;__forwarding-&gt;__block_obj</div></pre></td></tr></table></figure>
<p>栈上的 <code>__block</code> 在被拷贝到堆内存时，会改变栈内存的 <code>__forwarding</code> 指针，让其指向堆内存的 <code>__block</code> 变量。 所以通过这个设计让 访问的 <code>__block</code> 变量无论在 Block 中还是 Block外，<code>__block</code>变量是在堆内存还是栈内存上，访问的都是同一个 <code>__block</code> 变量。</p>
<p><br></p>
<h4 id="为什么-Block-中的静态变量可以修改，-而自动变量不能修改"><a href="#为什么-Block-中的静态变量可以修改，-而自动变量不能修改" class="headerlink" title="为什么 Block 中的静态变量可以修改， 而自动变量不能修改?"></a>为什么 Block 中的静态变量可以修改， 而自动变量不能修改?</h4><p>上面讲到 Block 对应的结构体因为保存的是 <code>静态变量</code> 的类型的指针，所以 <code>静态变量</code> 可以在 Block 中被重新赋值。那自动变量为什么不也设计成这样，使其拥有在 Block 中被重新赋值的能力呢?  这是因为自动变量的超出其所在的函数作用域时就会被销毁掉。但是 Block 又可以超出其自身作用域而存在。如果像对待 <code>静态变量</code> 那样去对待 <code>自动变量</code> ，很可能出现的情况就是当 Block 去操作/访问 <code>自动变量</code> 时。自动变量已经被销毁。</p>
<p><br></p>
<h2 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h2><p>这个关于 Block 的<a href="http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/" target="_blank" rel="external">小测试</a> 这是在唐巧的 blog 《<a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a>》 中发现的， 觉得很能考察对 Block 的理解程度，做到全对感觉对 Block 了解就很清楚了。</p>
<p><br></p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="external">Objective-C 高级编程</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/03/30/Objective-C Block Part3 - Weak-Strong Dance/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'tao4blog';
var disqus_identifier = '2017/03/30/Objective-C Block Part2 - 实现原理/';
var disqus_title = 'Objective-C Block Part2 - 实现原理';
var disqus_url = 'http://yoursite.com/2017/03/30/Objective-C Block Part2 - 实现原理/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//tao4blog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Liu Tao</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>