<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS GCD 详解 · tao's blog</title><meta name="description" content="iOS GCD 详解 - Liu Tao"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="tao's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/573555508" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/taooba" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS GCD 详解</h1><div class="post-info">Feb 21, 2017</div><div class="post-content"><h1 id="什么是-GCD"><a href="#什么是-GCD" class="headerlink" title="什么是 GCD ?"></a>什么是 GCD ?</h1><p><code>GCD</code> 全称为 <code>Grand Central Dispatch</code> ， 是一个异步执行任务的技术之一。 一般将应用程序中线程管理用的代码再系统级中实现。 开发者只需要定义想执行的任务并追加到适当的 <code>Dispatch Queue</code> 中， <code>GCD</code> 就能生成必要的线程并计划执行任务。 由于线程管理是作为系统的一部分来实现的， 因此可统一管理，也可执行任务，这样就比以前的线程更有效率。</p>
<p>相对于直接去写多线程的代码。通过 <code>GCD</code> 去使用多线程技术不仅非常简单，并且避免一些多线程操作中可能出现的问题。开发者要做的只是定义想执行的任务并追加到适当的 <code>Dispatch Queue</code> 中。</p>
<h1 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h1><h4 id="Dispatch-Queue-介绍"><a href="#Dispatch-Queue-介绍" class="headerlink" title="Dispatch Queue 介绍"></a>Dispatch Queue 介绍</h4><p><code>Dispatch Queue</code> 是执行等待任务的队列。在使用 <code>GCD</code> 执行任务时，添加任务到对应的 <code>Dispatch Queue</code> 中。由 <code>Dispatch Queue</code> 控制怎么在线程上执行任务。<code>Dispatch_Queue</code> 按照任务追加的顺序执行(FIFO)。  <code>Dispatch Queue</code> 分类两种类型: </p>
<ul>
<li><strong>Serial Dispatch Queue:</strong> 是一个串行队列，添加到这个队列中的任务会按照顺序一个任务执行完后才会执行下一个任务。</li>
</ul>
<ul>
<li><strong>Concurrent Dispatch Queue:</strong> 是一个并行队列，添加到这个队列中的任务会多个任务同时执行。但是具体同时能执行多少个任务，这个<code>XNU 内核</code> 去帮我们管理的。</li>
</ul>
<h4 id="创建-Dispatch-Queue"><a href="#创建-Dispatch-Queue" class="headerlink" title="创建 Dispatch Queue"></a>创建 Dispatch Queue</h4><p>获取上面两种 <code>Dispatch Queue</code> 可以通过 <code>dispatch_queue_create</code> 函数去创建。这个函数返回代表 <code>Dispatch Queue</code> 的 <code>dispatch_queue_t</code> 类型变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t dispatch_queue_create(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr);</div><div class="line">// 其中第一个参数传入一个 C 字符串，作为名字来标识一个 Dispatch Queue ，这个名字在调试中非常有用，会显示在调试面板上。</div><div class="line">// 第二个参数如果创建 Serial Dispatch Queue 则填入 NULL 。 </div><div class="line">// 如果需要创建 Concurrent Dispatch Queue 则填入DISPATCH_QUEUE_CONCURRENT。</div></pre></td></tr></table></figure>
<h4 id="获取系统提供的-Dispatch-Queue"><a href="#获取系统提供的-Dispatch-Queue" class="headerlink" title="获取系统提供的 Dispatch Queue"></a>获取系统提供的 Dispatch Queue</h4><p>如果不自己创建 <code>Dispatch Queue</code> ，系统也开发者提供了<code>Main Dispatch Queue</code> <code>Global Dispatch Queue</code> 。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mainQueue             = dispatch_get_main_queue();</div><div class="line">dispatch_queue_t globalQueueHigh       = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</div><div class="line">dispatch_queue_t globalQueueDefault    = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_queue_t globalQueueLow        = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</div><div class="line">dispatch_queue_t globalQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</div><div class="line"></div><div class="line">// dispatch_get_main_queue 方法获得的是 Serial Dispatch Queue，主线程就是在这个 Dispatch Queue 内。</div><div class="line">// dispatch_get_global_queue 方法获得都是 Concurrent Dispatch Queue。其第一个参数表示优先级，第二是保留字段(填0);</div></pre></td></tr></table></figure>
<h1 id="dispatch-async-amp-dispatch-sync"><a href="#dispatch-async-amp-dispatch-sync" class="headerlink" title="dispatch_async &amp; dispatch_sync"></a>dispatch_async &amp; dispatch_sync</h1><h4 id="dispatch-async-amp-dispatch-sync-介绍"><a href="#dispatch-async-amp-dispatch-sync-介绍" class="headerlink" title="dispatch_async &amp; dispatch_sync 介绍"></a>dispatch_async &amp; dispatch_sync 介绍</h4><p> <code>dispatch_async</code> 和 <code>dispatch_sync</code> 这两个函数都可以把 <code>Block任务</code> 绑定到指定的 <code>Dispatch Queue</code> 中执行。区别从方法名中就可以看出。<code>dispatch_async</code> 是异步执行，<code>dispatch_sync</code> 是同步执行。看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;1...&quot;);</div><div class="line">dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">    sleep(1); NSLog(@&quot;dispatch_sync&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;2...&quot;);</div><div class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">    sleep(1); NSLog(@&quot;dispatch_async&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;3...&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 上面这段代码执行的输出是:</div><div class="line">2017-02-22 21:47:18.545 OCGCD[47679:28023198] 1...</div><div class="line">2017-02-22 21:47:19.605 OCGCD[47679:28023198] dispatch_sync</div><div class="line">2017-02-22 21:47:19.606 OCGCD[47679:28023198] 2...</div><div class="line">2017-02-22 21:47:19.606 OCGCD[47679:28023198] 3...</div><div class="line">2017-02-22 21:47:20.675 OCGCD[47679:28023256] dispatch_async</div></pre></td></tr></table></figure>
<p>可以看出 <code>dispatch_sync</code> 这个函数会等到其 Block 内的任务执行完毕才会返回，然后继续往下执行。<code>dispatch_async</code> 则是直接返回继续往下执行，其 Block 内的任务会异步的去执行。</p>
<h4 id="dispatch-async-amp-dispatch-sync-和线程"><a href="#dispatch-async-amp-dispatch-sync-和线程" class="headerlink" title="dispatch_async &amp; dispatch_sync 和线程"></a>dispatch_async &amp; dispatch_sync 和线程</h4><p>上面说过 <code>GCD</code> 的背后是系统内核在管理线程，那 <code>dispatch_async</code> 和 <code>dispatch_sync</code> 执行相关了队列和线程那些关联呢? 看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serial     = dispatch_queue_create(&quot;io.tao.serial&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_queue_t concurrent = dispatch_queue_create(&quot;io.tao.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_queue_t mainQueue  = dispatch_get_main_queue();</div><div class="line"></div><div class="line">dispatch_sync (serial,     ^&#123; NSLog(@&quot;1: %@&quot;, [NSThread currentThread]); &#125;);</div><div class="line">dispatch_async(serial,     ^&#123; NSLog(@&quot;2: %@&quot;, [NSThread currentThread]); &#125;);</div><div class="line">dispatch_sync (concurrent, ^&#123; NSLog(@&quot;3: %@&quot;, [NSThread currentThread]); &#125;);</div><div class="line">dispatch_async(concurrent, ^&#123; NSLog(@&quot;4: %@&quot;, [NSThread currentThread]); &#125;);</div><div class="line">dispatch_async(mainQueue,  ^&#123; NSLog(@&quot;5: %@&quot;, [NSThread currentThread]); &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 上面这段代码执行的输出是:</div><div class="line">2017-02-22 22:29:04.783 OCGCD[50871:28074784] 1: &lt;NSThread: 0x6080000646c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">2017-02-22 22:29:04.783 OCGCD[50871:28074818] 2: &lt;NSThread: 0x60000006ba40&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">2017-02-22 22:29:04.783 OCGCD[50871:28074784] 3: &lt;NSThread: 0x6080000646c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">2017-02-22 22:29:04.784 OCGCD[50871:28074819] 4: &lt;NSThread: 0x60000006b800&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2017-02-22 22:29:04.789 OCGCD[50871:28074784] 5: &lt;NSThread: 0x6080000646c0&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>由上面的例子得出，无论是 <code>Serial Dispatch Queue</code> 还是 <code>Concurrent Dispatch Queue</code></p>
<p>通过 <code>dispatch_sync</code> 函数执行的都会在当前线程中执行任务。</p>
<p>通过 <code>dispatch_async</code> 函数执行的都会在子线程中执行任务。</p>
<p>但是有一个例外是 使用 <code>dispatch_async</code> 执行 <code>mainQueue</code> 队列也是在当前线程中执行的。永远都只会在主线程中执行。</p>
<h4 id="dispatch-sync-和-死锁"><a href="#dispatch-sync-和-死锁" class="headerlink" title="dispatch_sync 和 死锁"></a>dispatch_sync 和 死锁</h4><p>细心的人可能已经发现，上面的例子没有出现下面这行代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(mainQueue,  ^&#123; NSLog(@&quot;6: %@&quot;, [NSThread currentThread]); &#125;);</div></pre></td></tr></table></figure>
<p>因为这行代码在主线程中执行时会产生死锁，程序会 <strong>Carsh</strong> 。产生死锁的原因是: 因为该代码在 <code>Main Dispatch Queue(主线程)</code> 中使用 <code>dispatch_sync</code> 在 <code>Main Dispatch Queue(主线程)</code> 上执行 <code>Block 任务</code> ， <code>Main Dispatch Queue(主线程)</code> 在一直等着 <code>dispatch_sync</code> 函数返回再继续执行，但是 <code>dispatch_sync</code> 又需要在 <code>Main Dispatch Queue(主线程)</code> 执行<code>Block 任务</code>，所以这就像是一个死胡同，永远也等不到 <code>dispatch_sync</code>  函数返回。下面这个例子也是同样的问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serial = dispatch_queue_create(&quot;io.tao.q1&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_async(serial, ^&#123;</div><div class="line">    dispatch_sync(serial, ^&#123; NSLog(@&quot;Are you ok?&quot;); &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>所以在使用 <code>dispatch_sync</code> 函数去执行 <code>Serial Dispatch Queue</code> 队列时，要特别小心死锁的问题。在当前 <code>Dispatch Queue</code> 上去让 <code>dispatch_queue</code> 在当前 <code>Dispatch Queue</code> 执行任务时就会产生死锁。</p>
<h1 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h1><h4 id="dispatch-after-介绍"><a href="#dispatch-after-介绍" class="headerlink" title="dispatch_after 介绍"></a>dispatch_after 介绍</h4><p> <code>dispatch_after</code> 可以让 <code>Block 任务</code> 在指定时间后加入到 <code>Dispatch Queue</code> 中执行，并非在指定时间后执行 <code>Block 任务</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);</div><div class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;dispatch_after&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 上面的例子等同于 3 秒之后调用下面的代码</div><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">	NSLog(@&quot;dispatch_after&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="dispatch-time-介绍"><a href="#dispatch-time-介绍" class="headerlink" title="dispatch_time 介绍"></a>dispatch_time 介绍</h4><p>上面的例子中 <code>dispatch_after</code> 第一个参数是指定时间 <code>dispatch_time_t</code> 类型的值。<code>dispatch_time_t</code> 函数定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta);</div><div class="line">// 第一个参数指定时间的开始, 一般使用 DISPATCH_NOTHROW 表示现在的时间。</div><div class="line">// 第二个参数表示延后的时间，默认单位是纳秒, 可以 * NSEC_PER_SEC NSEC_PER_MSEC NSEC_PER_USEC 相关时间单位倍数来转换</div></pre></td></tr></table></figure>
<h1 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h1><h4 id="dispatch-apply-介绍"><a href="#dispatch-apply-介绍" class="headerlink" title="dispatch_apply 介绍"></a>dispatch_apply 介绍</h4><p><code>dispatch_apply</code> 可以多次执行一个队列里的 Block 任务，它会为 Block 任务提供一个计次的参数。  它和 <code>dispatch_sync</code> 一样，需要等到所有 Block 任务执行完，这个函数才会返回。 所以也要主要死锁的问题，当队列是 <code>Serial Dispatch Queue</code> 时，不要在当前 <code>Dispatch Queue</code> 上去让 <code>dispatch_apply</code> 在当前 <code>Dispatch Queue</code> 执行任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_apply(3, dispatch_get_global_queue(0, 0), ^(size_t index) &#123;</div><div class="line">    NSLog(@&quot;%zu&quot;, index);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;done&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 上面的例子的输出，done 总是在最后输出。刚好可以验证上面的说法。dispatch_applay 是同步去执行的</div><div class="line">2017-02-23 13:23:27.041 OCGCD[14310:28921393] 1</div><div class="line">2017-02-23 13:23:27.042 OCGCD[14310:28921396] 2</div><div class="line">2017-02-23 13:23:27.042 OCGCD[14310:28921344] 0</div><div class="line">2017-02-23 13:23:27.043 OCGCD[14310:28921344] done</div></pre></td></tr></table></figure>
<h1 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h1><h4 id="用其设置队列的优先级"><a href="#用其设置队列的优先级" class="headerlink" title="用其设置队列的优先级"></a>用其设置队列的优先级</h4><p>上面有例子通过 <code>dispatch_get_global_queue</code> 去生成不同优先级的队列。通过 <code>dispatch_queue_create</code> 函数生成的 <strong>Dispatch Queue</strong> 的优先级都是默认的，如果要改变它们优先级可以通过 <code>dispatch_set_target_queue</code> ，看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</div><div class="line">dispatch_queue_t queue 	   = dispatch_queue_create(&quot;io.tao.serial&quot;, NULL);</div><div class="line">dispatch_set_target_queue(queue, queueHigh);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 上面的例子，把默认优先级的 queue， 设置成和 queueHigh 一样的高优先级</div><div class="line">// 第一个参数填入要设置的 Dispatch Queue</div><div class="line">// 第二个参数填入要参照的目标 Dispatch Queue</div></pre></td></tr></table></figure>
<h4 id="设置多个-Serial-Dispatch-Queue-的执行顺序"><a href="#设置多个-Serial-Dispatch-Queue-的执行顺序" class="headerlink" title="设置多个 Serial Dispatch Queue 的执行顺序"></a>设置多个 Serial Dispatch Queue 的执行顺序</h4><p>多个 <code>Serial Dispatch Queue</code> 是并行执行的。但是开发碰到了要让它们串行执行的需求时，也可以通过 <code>dispatch_set_target_queue</code> 方法来实现。只需要把多个 <code>Serial Dispatch Queue</code> 设置成同一个目标  <code>Serial Dispatch Queue</code>  就可以了。看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue  = dispatch_queue_create(&quot;io.tao.serial&quot;, NULL);</div><div class="line">dispatch_queue_t serialQueue1 = dispatch_queue_create(&quot;io.tao.app.serial1&quot;, NULL);</div><div class="line">dispatch_queue_t serialQueue2 = dispatch_queue_create(&quot;io.tao.app.serial2&quot;, NULL);</div><div class="line">dispatch_queue_t serialQueue3 = dispatch_queue_create(&quot;io.tao.app.serial3&quot;, NULL);</div><div class="line"></div><div class="line">dispatch_set_target_queue(serialQueue1, serialQueue);</div><div class="line">dispatch_set_target_queue(serialQueue2, serialQueue);</div><div class="line">dispatch_set_target_queue(serialQueue3, serialQueue);</div><div class="line"></div><div class="line">NSLog(@&quot;start...&quot;);</div><div class="line">dispatch_async(serialQueue1, ^&#123;</div><div class="line">    sleep(1);</div><div class="line">    NSLog(@&quot;serialQueue1&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(serialQueue2, ^&#123;</div><div class="line">    NSLog(@&quot;serialQueue2&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(serialQueue3, ^&#123;</div><div class="line">    NSLog(@&quot;serialQueue3&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;end...&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 下面是上面例子的控制台输出。</div><div class="line">// serialQueue1, serialQueue2, serialQueue3 成功的按照顺序输出了。 </div><div class="line">2017-02-23 14:15:21.033 OCGCD[18304:28985032] start...</div><div class="line">2017-02-23 14:15:21.033 OCGCD[18304:28985032] end...</div><div class="line">2017-02-23 14:15:22.105 OCGCD[18304:28985092] serialQueue1</div><div class="line">2017-02-23 14:15:22.105 OCGCD[18304:28985092] serialQueue2</div><div class="line">2017-02-23 14:15:22.105 OCGCD[18304:28985092] serialQueue3</div></pre></td></tr></table></figure>
<h1 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h1><h4 id="dispatch-group-介绍"><a href="#dispatch-group-介绍" class="headerlink" title="dispatch_group 介绍"></a>dispatch_group 介绍</h4><p><code>dispatch_group</code> 允许把多个 <strong>Dispatch Queue</strong> 添加到一个 Group 中，等 Group 中所有的 <strong>Dispatch Queue</strong> 执行完成后，Group 会执行添加的特定 <code>Block 任务</code>。无论是 <strong>Serial Dispatch Queue</strong> 还是 <strong>Concurrent Dispatch Queue</strong> 都是有效的。 这在实际开发中非常有用。看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serial     = dispatch_queue_create(&quot;io.tao.serial&quot;, NULL);</div><div class="line">dispatch_queue_t concurrent = dispatch_queue_create(&quot;io.tao.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_group_t group      = dispatch_group_create();</div><div class="line"></div><div class="line">dispatch_group_async(group, serial,     ^&#123; sleep(3); NSLog(@&quot;serial1&quot;);&#125;);</div><div class="line">dispatch_group_async(group, serial,     ^&#123; sleep(2); NSLog(@&quot;serial2&quot;);&#125;);</div><div class="line">dispatch_group_async(group, concurrent, ^&#123; sleep(1); NSLog(@&quot;concurrent1&quot;);&#125;);</div><div class="line">dispatch_group_async(group, concurrent, ^&#123; sleep(2); NSLog(@&quot;concurrent2&quot;);&#125;);</div><div class="line"></div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;Group 中所有的 Dispatch Queue 已执行完&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 下面是上面例子的控制台输出。</div><div class="line">2017-02-23 14:30:06.566 OCGCD[19452:29004031] concurrent1</div><div class="line">2017-02-23 14:30:07.494 OCGCD[19452:29004033] concurrent2</div><div class="line">2017-02-23 14:30:08.494 OCGCD[19452:29004030] serial1</div><div class="line">2017-02-23 14:30:10.561 OCGCD[19452:29004030] serial2</div><div class="line">2017-02-23 14:30:10.561 OCGCD[19452:29003990] Group 中所有的 Dispatch Queue 已执行完</div></pre></td></tr></table></figure>
<p>在添加到 <strong>Dispatch Group</strong> 中的所有任务全部执行结束后， 就会把 <code>dispatch_group_notify</code> 中的 <code>Block 任务</code> 添加对指定队列中执行。来做一些结束工作。</p>
<h4 id="dispatch-group-wait-的使用"><a href="#dispatch-group-wait-的使用" class="headerlink" title="dispatch_group_wait 的使用"></a>dispatch_group_wait 的使用</h4><p>除了通过 <code>dispatch_group_notify</code> 获得 <strong>Dispatch Group</strong> 执行完的通知，也能通过 <code>dispatch_group_wait</code> 函数来获取结束通知。这个函数会一直等着 <strong>Dispatch Group</strong> 执行完成才会返回。 它就像是一个断点，把当前线程给断住，直到 Group 的所有任务执行完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t concurrent = dispatch_queue_create(&quot;io.tao.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_group_t group      = dispatch_group_create();</div><div class="line"></div><div class="line">dispatch_group_async(group, concurrent, ^&#123; sleep(3); NSLog(@&quot;concurrent1&quot;);&#125;);</div><div class="line">dispatch_group_async(group, concurrent, ^&#123; sleep(2); NSLog(@&quot;concurrent2&quot;);&#125;);</div><div class="line"></div><div class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line">NSLog(@&quot;Dispatch Group 中所有任务都已执行完毕&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 上面例子的控制台输出。刚好能证明上面的观点</div><div class="line">2017-02-23 14:44:16.883 OCGCD[20511:29021074] concurrent2</div><div class="line">2017-02-23 14:44:17.881 OCGCD[20511:29021077] concurrent1</div><div class="line">2017-02-23 14:44:17.882 OCGCD[20511:29021036] Dispatch Group 中所有任务都已执行完毕</div></pre></td></tr></table></figure>
<h1 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h1><h4 id="dispatch-barrier-async-介绍"><a href="#dispatch-barrier-async-介绍" class="headerlink" title="dispatch_barrier_async 介绍"></a>dispatch_barrier_async 介绍</h4><p><strong>Barrier</strong> 如同它的名字一样，它就像一个屏障把 <strong>Concurrent Dispatch Queue</strong> 里的多个任务给隔离开了。 <strong>Concurrent Dispatch Queue</strong>里的 <code>Block 任务</code> 是并行执行的，有时候想控制它们执行一部分 <code>Block 任务</code> 后，再执行特定操作，最后执行剩下的其他的 <code>Block 任务</code>。    <code>dispatch_barrier_async</code> 就可以帮我们做到。看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t concurrent = dispatch_queue_create(&quot;io.tao.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 1&quot;);&#125;);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 2&quot;);&#125;);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 3&quot;);&#125;);</div><div class="line">dispatch_barrier_sync(concurrent, ^&#123; sleep(3); NSLog(@&quot;barrier&quot;);&#125;);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 4&quot;);&#125;);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 5&quot;);&#125;);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 6&quot;);&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 上面例子的控制台输出。注意每条 Log 的时间，concurrent 3 到 barrier 间隔了3秒</div><div class="line">2017-02-23 15:17:04.968 OCGCD[22872:29058218] concurrent 1</div><div class="line">2017-02-23 15:17:04.968 OCGCD[22872:29058220] concurrent 2</div><div class="line">2017-02-23 15:17:04.969 OCGCD[22872:29058217] concurrent 3</div><div class="line">2017-02-23 15:17:08.039 OCGCD[22872:29058165] barrier</div><div class="line">2017-02-23 15:17:08.040 OCGCD[22872:29058217] concurrent 4</div><div class="line">2017-02-23 15:17:08.040 OCGCD[22872:29058220] concurrent 5</div><div class="line">2017-02-23 15:17:08.040 OCGCD[22872:29058218] concurrent 6</div></pre></td></tr></table></figure>
<h1 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h1><p><strong>Dispatch Semaphore</strong> 是基于计数的信号，在 <code>GCD</code> 中控制并发队列同步的方法之一。 多个队列同时访问修改一个数据时，可能会产生数据不一致的情况，又是程序还会 <strong>Carsh</strong>。这是就可以通过 <strong>Dispatch Semaphore</strong> 去解决。 </p>
<ul>
<li><code>dispatch_semaphore_create(1);</code>  会创建一个指定数字的信号量，这里是1。</li>
<li><code>dispatch_semaphore_wait</code> 函数当信号量 &gt;= 1时会把信号量-1，并返回函数 。否则则会一直卡在此处，或者等到超时。</li>
<li><code>dispatch_semaphore_signal</code> 发送一个信号，让信号量+1。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</div><div class="line">NSMutableArray *marr = [NSMutableArray array];</div><div class="line">for (int i=0; i &lt; 9999; ++i) &#123;</div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">        [marr addObject:[NSNumber numberWithInt:i]];</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 上面例子执行完后，marr 里会包含 9999个 NSNumber 对象。因为通过 Dispatch Semaphore 控制始终只有一个线程在操作 marr。所以没有数据竞争的问题</div></pre></td></tr></table></figure>
<h1 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend / dispatch_resume"></a>dispatch_suspend / dispatch_resume</h1><p>这两个函数可以控制 <strong>Dispatch Queue</strong> 暂停(suspend) 和 恢复(resume)。当 <code>dispatch_suspend(queue)</code> 执行时 <strong>queue</strong> 被暂停。已经加入到 <code>queue</code> 中的任务会继续执行。后面在再加入的任务会暂停，一直等到 <code>dispatch_resume(queue)</code> 被执行。看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;io.tao.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">dispatch_async(queue, ^&#123; sleep(2); NSLog(@&quot;queue1&quot;); &#125;);</div><div class="line">dispatch_async(queue, ^&#123; NSLog(@&quot;queue2&quot;); &#125;);</div><div class="line"></div><div class="line">NSLog(@&quot;queue supend...&quot;);</div><div class="line">dispatch_suspend(queue);</div><div class="line">dispatch_async(queue, ^&#123; NSLog(@&quot;queue3&quot;); &#125;);</div><div class="line"></div><div class="line">sleep(8);</div><div class="line">NSLog(@&quot;queue resume...&quot;);</div><div class="line">dispatch_resume(queue);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 上面例子的控制台输出。注意每条 Log 的时间。刚好能证明上面的结论</div><div class="line">2017-02-23 16:30:19.829 OCGCD[28759:29155110] queue supend...</div><div class="line">2017-02-23 16:30:19.829 OCGCD[28759:29155170] queue2</div><div class="line">2017-02-23 16:30:21.889 OCGCD[28759:29155168] queue1</div><div class="line">2017-02-23 16:30:27.903 OCGCD[28759:29155110] queue resume...</div><div class="line">2017-02-23 16:30:27.904 OCGCD[28759:29155167] queue3</div></pre></td></tr></table></figure>
<h1 id="GCD-的内存管理"><a href="#GCD-的内存管理" class="headerlink" title="GCD 的内存管理"></a>GCD 的内存管理</h1><p>在 iOS6 or Mac OS X 10.8 以前 GCD 对象并没有纳入 <code>ARC</code> 管理范围。通过带 <code>dispatch_xxx_create</code> 创建的值都需开发者负责释放。<code>dispatch_retain</code> <code>dispatch_release</code> 。iOS6 or Mac OS X 10.8 之后使用的是  ARC 的话就不需要手动管理内存了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/01/27/一个十年的结束, 另一个开始/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'tao4blog';
var disqus_identifier = '2017/02/21/iOS GCD 详解/';
var disqus_title = 'iOS GCD 详解';
var disqus_url = 'http://yoursite.com/2017/02/21/iOS GCD 详解/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//tao4blog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Liu Tao</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>