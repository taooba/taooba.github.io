<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tao&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-11T09:05:16.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Liu Tao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript - 函数重载</title>
    <link href="http://yoursite.com/2017/09/11/JavaScript%20-%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <id>http://yoursite.com/2017/09/11/JavaScript - 函数重载/</id>
    <published>2017-09-11T09:03:31.000Z</published>
    <updated>2017-09-11T09:05:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>函数重载</strong>就是函数名相通，但输入输出不同的一组函数。或者说就是具有相同名字不同参数的一组函数。在 JavaScript 中函数名就是存放函数对象的变量的变量名，标识函数的就是这个变量名，并没有涉及到函数的参数。所以在语言层面上 JavaScript 的是不支持<strong>函数重载</strong>的。但是可以使用一些技巧来变相的实现<strong>函数重载</strong>。</p>
<h1 id="在函数内区分输入参数来重载"><a href="#在函数内区分输入参数来重载" class="headerlink" title="在函数内区分输入参数来重载"></a>在函数内区分输入参数来重载</h1><p>在函数的内部区分函数的输入参数，根据输入参数的不同就在函数内部执行不同的逻辑，来达到<strong>函数重载</strong>的效果。比如根据输入参数的个数或者类型来执行不同的逻辑。下面的例子利用函数的内部属性 <code>arguments.length</code> ，根据输入参数的个数来执行不同的逻辑:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span>(<span class="built_in">arguments</span>.length) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"输入 0 个参数..."</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"输入 1 个参数..."</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"输入 1 个以上的参数..."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func();		<span class="comment">// 输出: 输入 0 个参数...</span></div><div class="line">func(<span class="number">0</span>);	<span class="comment">// 输出: 输入 1 个参数...</span></div><div class="line">func(<span class="number">0</span>, <span class="number">1</span>);	<span class="comment">// 输出: 输入 1 个以上的参数...</span></div></pre></td></tr></table></figure>
<h1 id="利用闭包来进行重载"><a href="#利用闭包来进行重载" class="headerlink" title="利用闭包来进行重载"></a>利用闭包来进行重载</h1><p>这种方法是出自<em>《JavaScript 忍者秘籍》</em>中，极其的巧妙和优雅! 利用闭包来进行<strong>函数重载</strong>，在调用重载函数时看起来和其他支持<strong>函数重载</strong>语言非常相似。下面的一个例子采用了这种方法进行<strong>函数重载</strong>，为一个对象添加三个不同的函数，根据输入的参数数量不同来调用不同的函数，输出不同的内容: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addMethod</span>(<span class="params">object, name, fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> old = object[name];</div><div class="line">  object[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (fn.length === <span class="built_in">arguments</span>.length) &#123;</div><div class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> old === <span class="string">"function"</span>) &#123;</div><div class="line">      <span class="keyword">return</span> old.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">addMethod(obj, <span class="string">"func"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"调用了无参数的 func 方法"</span>);</div><div class="line">&#125;)</div><div class="line">addMethod(obj, <span class="string">"func"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg0</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"调用了一个参数的 func 方法"</span>);</div><div class="line">&#125;)</div><div class="line">addMethod(obj, <span class="string">"func"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"调用了两个参数的 func 方法"</span>);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">obj.func();     <span class="comment">// 输出: 调用了无参数的 func 方法</span></div><div class="line">obj.func(<span class="number">1</span>);    <span class="comment">// 输出: 调用了一个参数的 func 方法</span></div><div class="line">obj.func(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 输出: 调用了两个参数的 func 方法</span></div></pre></td></tr></table></figure>
<p>上面的代码块在调用 <code>func()</code> 方法时，成功的根据参数数量的不同调用了不同的函数。其中 <code>addMethod()</code> 是其实现<strong>函数重载</strong>的关键。 <code>addMethod()</code> 函数为指定对象绑定了一个闭包，并且又保存了老闭包。闭包又在 <code>[[scope]]</code> 私有属性中引用了当前执行的 <code>addMethod()</code> <strong>执行环境</strong>的<strong>变量对象</strong>，使其老闭包并不会被销毁，形成一个链表结构。无论为一个对象执行了多少次 <code>addMethod()</code> 方法，这个对象访问永远是最后一次添加的闭包。在这个闭包内会判断当前的调用参数是否符合当前<strong>作用域链</strong>中的 <code>fn</code> 函数，符合就执行，不符合则调用老闭包。一直追溯到这个链表的最开始。下面的图是模拟执行 <code>obj.func()</code> 流程: </p>
<p><img src="/Users/taooba/Desktop/javascript_function_overloading.png" alt="javascript_function_overloading"></p>
<h1 id="致敬-参考内容"><a href="#致敬-参考内容" class="headerlink" title="致敬 - 参考内容"></a>致敬 - 参考内容</h1><ul>
<li><a href="http://www.cnblogs.com/yugege/p/5539020.html" target="_blank" rel="external">浅谈JavaScript函数重载</a></li>
<li><a href="https://book.douban.com/subject/26638316/" target="_blank" rel="external">《JavaScript忍者秘籍》</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;函数重载&lt;/strong&gt;就是函数名相通，但输入输出不同的一组函数。或者说就是具有相同名字不同参数的一组函数。在 JavaScript 中函数名就是存放函数对象的变量的变量名，标识函数的就是这个变量名，并没有涉及到函数的参数。所以在语言层面上 JavaScr
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript - 初探函数</title>
    <link href="http://yoursite.com/2017/09/10/JavaScript%20-%20%E5%88%9D%E6%8E%A2%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/09/10/JavaScript - 初探函数/</id>
    <published>2017-09-10T02:58:52.000Z</published>
    <updated>2017-09-10T03:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中函数也是对象，它也拥有自己的属性和方法。可以把函数赋值给一个变量，也能把它当做参数传递给其他函数，或者是把函数当做返回值返回给调用方。 </p>
<h1 id="声明函数的三种方式"><a href="#声明函数的三种方式" class="headerlink" title="声明函数的三种方式"></a>声明函数的三种方式</h1><p>JavaScript 中有三种声明函数的方式: <strong>函数声明</strong>、<strong>函数表达式</strong>、<strong>Function 构造函数</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 1.函数声明 */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum_a</span>(<span class="params">arg0, arg1</span>)</span>&#123; </div><div class="line">  <span class="keyword">return</span> arg0 + arg1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** 2.函数表达式 */</span></div><div class="line"><span class="keyword">var</span> sum_b = <span class="function"><span class="keyword">function</span> (<span class="params">arg0, arg1</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> arg0 + arg1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** 3.构造函数 */</span></div><div class="line"><span class="keyword">var</span> sum_c = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"arg0"</span>, <span class="string">"arg1"</span>, <span class="string">"return arg0 + arg1"</span>);</div></pre></td></tr></table></figure>
<h3 id="函数声明的函数提升"><a href="#函数声明的函数提升" class="headerlink" title="函数声明的函数提升"></a>函数声明的函数提升</h3><p>第一种方式使用<strong>函数声明</strong>来定义函数和其他方式有个区别 — 它具有<strong>函数提升</strong>的特性。JS引擎会将函数提升至当前作用域的最顶端(比 var变量提升更靠前)，这就意味着在同一作用域下，可以在函数声明前调用函数。例如以下代码并不会报错:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>));	<span class="comment">// 输出: 3</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arg0, arg1</span>)</span>&#123; </div><div class="line">  <span class="keyword">return</span> arg0 + arg1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Function-构造函数说明"><a href="#Function-构造函数说明" class="headerlink" title="Function 构造函数说明"></a>Function 构造函数说明</h3><p>第三种方式使用<strong>构造函数</strong>来定义函数，<code>Function</code> 函数可以接受任意数量的参数，最后一个参数被看成是函数体，而最后一个参数前面的参数都被看错是新函数的参数。这种方式在实际使用并不常见，因为一个函数里面通常包含很多语句，全部它们以字符串的形式作为参数传递，代码可读性会变得很糟糕。并且这种语法会导致解析两次代码：第一次解析常规JavaScript代码，第二次是解析传入构造函数中的字符串，从而导致性能不上其他方式。</p>
<h1 id="JavaScript-函数的参数"><a href="#JavaScript-函数的参数" class="headerlink" title="JavaScript 函数的参数"></a>JavaScript 函数的参数</h1><p>JavaScript 的函数可以接受任意个参数，例如下面的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arg0, arg1</span>)</span>&#123; </div><div class="line">  <span class="keyword">return</span> arg0 + arg1;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> result = sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 输出: 3</span></div></pre></td></tr></table></figure>
<p><code>sum</code> 函数声明时显示它需要接受两个参数 <code>arg0</code> <code>arg1</code>，但是在调用它的时候传递了5个参数 <code>1, 2, 3, 4, 5</code>，这并没有影响它的正常运行，在 <code>sum</code> 函数内部可以取得预期的 <code>arg0:1</code> <code>arg1:2</code>。</p>
<h1 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h1><p>上面提到过函数也是对象，可以像其他类型的变量一样来使用函数变量。函数本质上是一个变量的引用指向了堆内存中函数对象，函数名就是变量名。所以一个函数可以拥有多个函数名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func_a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"吃了吗? 世界"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">/** 使用不带圆括号的函数名是访问函数对象，而非调用函数 */</span></div><div class="line"><span class="keyword">var</span> func_b = func_a;</div><div class="line"></div><div class="line">func_a();   <span class="comment">// 输出: 吃了吗? 世界</span></div><div class="line">func_b();   <span class="comment">// 输出: 吃了吗? 世界</span></div></pre></td></tr></table></figure>
<p>上面的例子定义了一个函数，这个函数内输出一段字符串，并把这个函数赋值给了 <code>func_a</code> 变量，然后再把 <code>func_a</code> 赋值给了 <code>func_b</code> 变量。此时 <code>func_a</code> <code>func_b</code> 变量的引用都同时指向这个函数，调用它们能得到相同的结果。</p>
<h3 id="不支持函数重载"><a href="#不支持函数重载" class="headerlink" title="不支持函数重载"></a>不支持函数重载</h3><p><strong>函数重载</strong>就是函数名称相通，但是输入输出不一样，或者说就是具有相同名字、不同参数列表的若干个函数。在 JavaScript 中函数名就是存放函数对象的变量的变量名，标识函数的就是这个变量名，并没有涉及到函数的参数。所以在语言层面上 JavaScript 的是不支持<strong>函数重载</strong>的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">arg0</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"函数1: "</span> + arg0);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"函数2: "</span> + arg0 + <span class="string">","</span> + arg1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">func(<span class="number">1</span>);	<span class="comment">// 输出: 函数2: 1,undefined</span></div><div class="line">func(<span class="number">1</span>, <span class="number">2</span>);	<span class="comment">// 输出: 函数2: 1,2</span></div></pre></td></tr></table></figure>
<p>像上面的例子中试图实现重载，但是后面的函数定义会覆盖前面的函数定义。它们最后调用的都是函数2。当然 JavaScript 可以通过一些技巧变相的实现重载。</p>
<h1 id="函数内部的属性-arugments"><a href="#函数内部的属性-arugments" class="headerlink" title="函数内部的属性 - arugments"></a>函数内部的属性 - arugments</h1><p>在 JavaScript 的函数内部可以访问到特殊的变量 <code>arugments</code>。<code>arguments</code> 变量装着调用这个函数时传递的所有参数，它是一个类似数组（<code>Array</code>）的对象，虽然它拥有 <code>length</code> 属性，但它并不是继承自 <code>Array</code>的。所以数组相关 <code>push()</code>  <code>pop()</code> 等方法不能使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">func(<span class="number">0</span>, <span class="number">1</span>);       <span class="comment">// 输出: &#123; '0': 0, '1': 1 &#125;</span></div><div class="line">func(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 输出: &#123; '0': 0, '1': 1, '2': 2, '3': 3 &#125;</span></div></pre></td></tr></table></figure>
<p>上面的代码块中的 <code>func()</code> 函数中虽然没有形参，但是可以通过 <code>arguments</code> 属性访问到它所接受到的所有参数。但是如果重新再函数内部声明定义了 <code>arguments</code> 属性，则会覆盖掉原有的内容。</p>
<h3 id="arguments-的自动更新"><a href="#arguments-的自动更新" class="headerlink" title="arguments 的自动更新"></a>arguments 的自动更新</h3><p>改变 <code>aruments</code> 内的值对应的参数值也会跟着改变。反之亦然，改变参数的值 <code>arguments</code> 中对应的值也会跟着改变。不过在<strong>严格模式</strong>中，改变参数的值并不会影响到 <code>arguments</code> 内的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 'use strict'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(arg); <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">100</span>;</div><div class="line">  <span class="built_in">console</span>.log(arg); <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">  arg = <span class="number">1000</span>;</div><div class="line">  <span class="built_in">console</span>.log(arg); <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line">func(<span class="number">10</span>);</div></pre></td></tr></table></figure>
<h3 id="arguments-的-callee"><a href="#arguments-的-callee" class="headerlink" title="arguments 的 callee"></a>arguments 的 callee</h3><p><code>arguments</code> 有一个 <code>callee</code> 属性，该属性指向当前函数。可以使用这个 <code>callee</code> 属性来实现递归调用。不过 <code>callee</code> 属性在严格模式中不能访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">idx</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(idx);</div><div class="line">  <span class="keyword">if</span> (idx &gt; <span class="number">0</span>) &#123; <span class="built_in">arguments</span>.callee(--idx); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func(<span class="number">2</span>);	<span class="comment">// 依次输出: 2, 1, 0</span></div></pre></td></tr></table></figure>
<h1 id="致敬-参考内容"><a href="#致敬-参考内容" class="headerlink" title="致敬 - 参考内容"></a>致敬 - 参考内容</h1><ul>
<li><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="external">《JavaScript 高级程序设计》</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 中函数也是对象，它也拥有自己的属性和方法。可以把函数赋值给一个变量，也能把它当做参数传递给其他函数，或者是把函数当做返回值返回给调用方。 &lt;/p&gt;
&lt;h1 id=&quot;声明函数的三种方式&quot;&gt;&lt;a href=&quot;#声明函数的三种方式&quot; class=&quot;hea
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript - this指向</title>
    <link href="http://yoursite.com/2017/09/09/JavaScript%20-%20this%E6%8C%87%E5%90%91/"/>
    <id>http://yoursite.com/2017/09/09/JavaScript - this指向/</id>
    <published>2017-09-09T01:24:45.000Z</published>
    <updated>2017-09-09T01:26:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的 <code>this</code> 的关键字相对于一般语言非常的灵活，不过无论是在<strong>全局执行环境</strong>中还是<strong>函数执行环境</strong>中，<code>this</code> 关键字的本质就是<strong>执行环境</strong>里的 <code>this</code> 变量。所以 <code>this</code> 的指向是在创建<strong>执行环境</strong>时确定的，并不是在声明定义时确定的。下面总结和归纳 <code>this</code> 在不同场景中的指向。</p>
<h1 id="全局执行环境"><a href="#全局执行环境" class="headerlink" title="全局执行环境"></a>全局执行环境</h1><p><strong>全局执行环境</strong>中 <code>this</code> 永远都指向全局本身，也就是说 <code>this</code>  == <code>window</code> == <strong>全局执行环境的变量对象</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.box_a = <span class="string">'box_a'</span>;    <span class="comment">// 通过 this 绑定到全局对象</span></div><div class="line">box_b = <span class="string">'box_b'</span>;         <span class="comment">// 通过var声明绑定到全局的变量对象上</span></div><div class="line"><span class="keyword">var</span> box_c = <span class="string">'box_c'</span>;     <span class="comment">// 通过直接赋值绑定到全局的变量对象上</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.box_a); <span class="comment">// 输出: box_a</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.box_b); <span class="comment">// 输出: box_b</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.box_c); <span class="comment">// 输出: box_c</span></div></pre></td></tr></table></figure>
<h1 id="函数执行环境"><a href="#函数执行环境" class="headerlink" title="函数执行环境"></a>函数执行环境</h1><p><strong>函数执行环境</strong>中的 <code>this</code> 指向，根据调用模式分为两种情况: <strong>方法调用模式</strong>、<strong>函数调用模式</strong>。</p>
<h3 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h3><p>当一个函数（Function）被保存为对象的一个属性时，我们称它为这个对象的方法（Method）。当一个函数以调用方法的方式调用时，其内部的 <code>this</code> 就会指向这个方法对应的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> box = <span class="string">'box_global'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.box);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj_a = &#123;<span class="attr">box</span>: <span class="string">'obj_a'</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj_b = &#123;<span class="attr">box</span>: <span class="string">'obj_b'</span>&#125;;</div><div class="line">obj_a.func = func;</div><div class="line">obj_b.func = func;</div><div class="line"></div><div class="line">obj_a.func();	<span class="comment">// 输出: &#123;box: "obj_a", func: f&#125; + obj_a</span></div><div class="line">obj_b.func();	<span class="comment">// 输出: &#123;box: "obj_b", func: f&#125; + obj_b</span></div></pre></td></tr></table></figure>
<p>上面的例子定义了一个 <code>func()</code> 函数，再把它赋值给了两个不同的对象，称为了它们的方法，再分别调用 <code>func()</code> 方法，虽然本质都是同一个函数，但是 <code>func()</code> 方法内部的 <code>this</code> 分别指向了它对应的对象 <code>obj_a</code> 和 <code>obj_b</code>。</p>
<h3 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h3><p>当一个函数并不是以对象调用方法的方式，而是直接调用函数，它就是函数调用模式。这种模式在<strong>非严格模式</strong>下函数中的 <code>this</code> 指向全局对象（在浏览器中是 <code>window</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">func();		<span class="comment">// 输出: Window&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>像下面例子中，<code>func()</code> 函数虽然是 <code>obj</code> 对象的一个方法，但是它的调用方式仍然是函数调用模式，所以 <code>func()</code> 函数内部的 <code>this</code> 指向 <code>window</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">func</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> func = obj.func;</div><div class="line">func();		<span class="comment">// 输出: Window&#123;...&#125;</span></div></pre></td></tr></table></figure>
<p>函数调用模式在<strong>严格模式</strong>下函数的中的 <code>this</code> 永远指向 <code>undefine</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">func();		<span class="comment">// 输出: undefine</span></div></pre></td></tr></table></figure>
<h1 id="new-构造函数中的-this"><a href="#new-构造函数中的-this" class="headerlink" title="new 构造函数中的 this"></a>new 构造函数中的 this</h1><p>在 JavaScript 中 <code>new</code> 关键字和函数一块使用，则我们称这个函数为构造函数。在构造函数的内部， <code>this</code> 指向新创建的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obama = <span class="keyword">new</span> Person(<span class="string">"奥观海"</span>, <span class="number">56</span>);</div><div class="line"><span class="built_in">console</span>.log(obama.name); 	<span class="comment">// 输出: 奥观海</span></div></pre></td></tr></table></figure>
<h1 id="call-apply-bind-对-this-的影响"><a href="#call-apply-bind-对-this-的影响" class="headerlink" title="call(),apply(),bind() 对 this 的影响"></a>call(),apply(),bind() 对 this 的影响</h1><p><code>call()</code> <code>apply()</code> <code>bind()</code>  这三个方法都可以让开发者改变执行函数内 <code>this</code> 的指向。</p>
<h3 id="call-apply-调用"><a href="#call-apply-调用" class="headerlink" title="call()/apply() 调用"></a>call()/apply() 调用</h3><p><code>call()</code> 和 <code>apply()</code> 这两个方法非常相似，它们的存在都是为了改变 <strong>this</strong> 的指向。它们接受的第一个参数都是执行函数内部 <code>this</code> 要指向的值。但在传递参数给执行函数时，<code>apply()</code> 是在第二个参数上接受一个参数数组，而 <code>call()</code> 则是和常规一样逐个把参数写在第二个参数 ~ 第n个参数中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj_a = &#123; <span class="attr">box</span>: <span class="string">"box_obj_a"</span> &#125;</div><div class="line"><span class="keyword">var</span> obj_b = &#123; <span class="attr">box</span>: <span class="string">"box_obj_b"</span> &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** 不传参数 */</span></div><div class="line">func.call(obj_a);           <span class="comment">// 输出: &#123;&#125; + &#123; box: 'box_obj_a' &#125;</span></div><div class="line">func.apply(obj_b);          <span class="comment">// 输出: &#123;&#125; + &#123; box: 'box_obj_b' &#125;</span></div><div class="line"></div><div class="line"><span class="comment">/** 传递参数 */</span></div><div class="line">func.call(obj_a, <span class="number">1</span>, <span class="number">2</span>);     <span class="comment">// 输出: &#123; '0': 1, '1': 2 &#125; + &#123; box: 'box_obj_a' &#125;</span></div><div class="line">func.apply(obj_b, [<span class="number">1</span>, <span class="number">2</span>]);  <span class="comment">// 输出: &#123; '0': 1, '1': 2 &#125; + &#123; box: 'box_obj_b' &#125;</span></div></pre></td></tr></table></figure>
<h3 id="bind-调用"><a href="#bind-调用" class="headerlink" title="bind() 调用"></a>bind() 调用</h3><p><code>bind()</code> 方法和 <code>call()</code> <code>apply()</code> 的区别是它可以延迟调用。调用 <code>bind()</code> 方法指定了 <code>this</code> 的指向和调用参数后会返回一个新的函数。后面再调用这个函数时它的 <code>this</code> 会指向它已绑定的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">box</span>: <span class="string">"box_obj"</span> &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** 返回一个新的函数 绑定了 this 和 参数 */</span></div><div class="line"><span class="keyword">var</span> bind_func = func.bind(obj, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">/** 后面再调用的时候仍然可以添加新参数 */</span></div><div class="line">bind_func(<span class="number">3</span>); <span class="comment">// 输出: &#123; '0': 1, '1': 2, '2': 3&#125; + &#123; box: 'box_obj' &#125;</span></div></pre></td></tr></table></figure>
<h1 id="致敬-参考内容"><a href="#致敬-参考内容" class="headerlink" title="致敬 - 参考内容"></a>致敬 - 参考内容</h1><ul>
<li><a href="https://book.douban.com/subject/3590768/" target="_blank" rel="external">《JavaScript 语言精粹》</a></li>
<li><a href="http://web.jobbole.com/83642/" target="_blank" rel="external">深入浅出妙用 Javascript 中 apply、call、bind</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 中的 &lt;code&gt;this&lt;/code&gt; 的关键字相对于一般语言非常的灵活，不过无论是在&lt;strong&gt;全局执行环境&lt;/strong&gt;中还是&lt;strong&gt;函数执行环境&lt;/strong&gt;中，&lt;code&gt;this&lt;/code&gt; 关键字的本质就是&lt;stro
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript - 执行环境&amp;作用域链&amp;闭包</title>
    <link href="http://yoursite.com/2017/09/08/JavaScript%20-%20%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83&amp;%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE&amp;%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2017/09/08/JavaScript - 执行环境&amp;作用域链&amp;闭包/</id>
    <published>2017-09-07T19:10:34.000Z</published>
    <updated>2017-09-07T19:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="执行环境-execution-context"><a href="#执行环境-execution-context" class="headerlink" title="执行环境 (execution context)"></a>执行环境 (execution context)</h1><p>JavaScript 的<strong>执行环境</strong>是一个很重要的概念，它最大用处是决定了在 <strong>执行环境</strong> 内部可以访问的数据和函数。<strong>执行环境</strong>的<strong>范围</strong>正好和<strong>作用域</strong>的<strong>范围</strong>是相对应的，分为<strong>全局执行环境</strong>和<strong>函数执行环境</strong>。</p>
<p><strong>全局执行环境: </strong> <strong>全局执行环境</strong>是最外围的<strong>执行环境</strong>，在所有代码执行之前解析器就已经创建好了<strong>全局执行环境</strong>。</p>
<p><strong>函数执行环境: </strong> 解析器在每次进入一个<strong>函数作用域</strong>内执行其内部的语句之前，都会为这个函数创建一个<strong>函数执行环境</strong>。即使是多次调用同一个函数(比如递归)，每次都会创建一个<strong>函数执行环境</strong>。</p>
<h3 id="执行环境中的内容"><a href="#执行环境中的内容" class="headerlink" title="执行环境中的内容"></a>执行环境中的内容</h3><p>每一个<strong>执行环境</strong>都包含着: <strong>变量对象</strong>、<strong>作用域链</strong> 、<code>this</code>指针。</p>
<ul>
<li><strong>变量对象(variable object): </strong> 包含着<strong>执行环境</strong>中定义的数据和函数，虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。<strong>函数执行环境</strong>的<strong>变量对象</strong>相对于<strong>全局执行环境</strong>的<strong>变量对象</strong>多一个<code>arguments</code> 属性来表示函数的参数。</li>
<li><strong>作用域链(scope chain): </strong> 按序保存着一些变量对象的引用，使得<strong>执行环境</strong>内能有序的访问外部环境的数据和函数。后面还会再详细讨论。</li>
<li><strong>this 指针: </strong> 就是平时开发人员写代码里写的 this 指针。</li>
</ul>
<p>下面使用一段代码来分析<strong>执行环境</strong>中所包含的内容:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> box_global = <span class="string">"box_global"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func_a</span>(<span class="params">arg_a0, arg_a1</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> box_a = <span class="string">"box_a"</span>;</div><div class="line">&#125;</div><div class="line">func_a(<span class="string">"arg_a0"</span>, <span class="string">"arg_a1"</span>);</div></pre></td></tr></table></figure>
<p>当代码执行到 <code>func_a</code> 函数最末尾时，拿 JS 对象模拟简化的<strong>执行环境</strong>如下图所示:</p>
<p><img src="http://ol972cch2.bkt.clouddn.com/javascript_excution_context.png" alt="Artboard"></p>
<h3 id="执行环境栈"><a href="#执行环境栈" class="headerlink" title="执行环境栈"></a>执行环境栈</h3><p>在解析器中有一个栈结构的<strong>执行环境栈</strong>来管理着所有的<strong>执行环境</strong>，当解析器进入一个函数之前为其生成一个<strong>执行环境</strong>，并把它压入到<strong>执行环境栈</strong>中。某个执行环境中的所有代码执行完毕后，把这个<strong>执行环境</strong>从<strong>执行环境栈</strong>中弹出，该环境被销毁，保存在其中的所有变量和函数也随之销毁。把控制权返回给之前的执行环境。JavaScript 程序中的执行流正是由这个方便的机制控制着。</p>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>当一个<strong>执行环境</strong>创建时，也会同时创建这个<strong>执行环境</strong>的<strong>作用域链</strong>，<strong>作用域链</strong>的作用就是保证在环境内有权访问的数据和函数能够有序的访问。<strong>作用域链</strong> 内部按序保存着一些<strong>变量对象</strong>的引用，<strong>作用域链</strong>的前端，始终都是当前所在环境的变量对象。<strong>作用域链</strong>中的下一个变量对象来自包含环境，一直一层一层延续到全局执行环境。全局执行环境的变量对象始终都是作用域链中的最后一个对象。例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> box_global = <span class="string">"box_global"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func_a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> box_a = <span class="string">"box_a"</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">func_b</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(box_a);       <span class="comment">// 输出: box_a</span></div><div class="line">    <span class="built_in">console</span>.log(box_global);  <span class="comment">// 输出: box_global  </span></div><div class="line">    <span class="built_in">console</span>.log(box);		  <span class="comment">// 报错: box is not defined</span></div><div class="line">  &#125;</div><div class="line">  func_b();</div><div class="line">&#125;</div><div class="line"></div><div class="line">func_a();</div></pre></td></tr></table></figure>
<p>上面的代码块执行到在 <code>func_c 函数</code> 内输出 <code>box_a</code> <code>box_global</code> <code>box</code> 对象。此时的<strong>执行环境</strong>图如下:</p>
<p><img src="http://ol972cch2.bkt.clouddn.com/javascript_scope_chain.png" alt="Artboard - 2"></p>
<p>在 <code>func_b 函数</code> 输出 <code>box_a</code> <code>box_global</code> <code>box</code> 时开始循这 <strong>func_b - 作用域链</strong> 开始逐个寻找，一直找到<strong>全局执行环境</strong>的<strong>变量对象</strong>。如果全局的<strong>变量对象</strong>中没找到则会报错，例如 <code>box</code> 变量。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是指能写携带和访问<strong>自由变量</strong>的函数，<strong>自由变量</strong>是指在函数中使用的，但既不是函数参数也不是函数的局部变量。举个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func_a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> message  = <span class="string">"你好呀，我叫赛丽亚!"</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(message);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> func_b = func_a();</div><div class="line">func_b(); <span class="comment">// 输出: 你好呀，我叫赛丽亚!</span></div></pre></td></tr></table></figure>
<p>上面的例子调用 <code>func_b()</code> 仍然正常输出了 <code>message</code> 变量里的内容，这好像和上面说的 <strong>执行环境</strong> 和 <strong>作用域链</strong> 的规则有冲突。调用 <code>func_b()</code> 函数在进入其函数内部之前创建好对应的 <strong>执行环境</strong>，同时创建它的 <strong>作用域链</strong>。<strong>作用域链</strong>中包含的<strong>变量对象</strong>依次为: <code>func_b</code> <strong>执行环境</strong>的<strong>变量对象</strong> → <strong>全局环境</strong>的<strong>变量对象</strong>。这样应该循着 <code>func_b</code> 的<strong>环境变量</strong>的<strong>作用域链</strong>上寻找应该访问不到 <code>message</code> 才对。但是事实上真正的 <strong>作用域链</strong> 中的<strong>变量对象</strong>依次为:   <code>func_b</code> <strong>执行环境</strong>的<strong>变量对象</strong> → <code>func_a</code> <strong>执行环境</strong>的变量对象 → <strong>全局环境</strong>的<strong>变量对象</strong>。</p>
<h3 id="函数的-scope-属性"><a href="#函数的-scope-属性" class="headerlink" title="函数的 [[scope]] 属性"></a>函数的 [[scope]] 属性</h3><p>之所以导致这样的原因，是因为<strong>执行环境</strong>的<strong>作用域链</strong>不是调用时决定的，而是函数定义时决定的。例如上面的例子，当执行到 <code>return function()…</code> 代码时，解析器会把当前的<strong>作用域链</strong>赋值给这个匿名函数的 <code>[[scope]]</code> 隐藏属性，这个<strong>作用域链</strong>里的<strong>变量对象</strong>依次为: <code>func_a</code> <strong>执行环境</strong>的变量对象 → <strong>全局环境</strong>的<strong>变量对象</strong>。然后再执行 <code>func_b()</code> 调用函数时创建它的 <strong>执行环境</strong>，再把 <code>func_b</code> 函数的 <code>[[scope]]</code> 属性赋值给<strong>执行环境</strong>的<code>scopeChain</code> 属性，然后再在这个<strong>作用域链</strong>的最前端添加上 <code>func_b</code> <strong>执行环境</strong>的<strong>变量对象</strong>。所以这个闭包可以访问到 <code>message</code> 属性。</p>
<h1 id="致敬-参考内容"><a href="#致敬-参考内容" class="headerlink" title="致敬 - 参考内容"></a>致敬 - 参考内容</h1><ul>
<li><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="external">《JavaScript 高级程序设计》</a></li>
</ul>
<ul>
<li><a href="https://tangxiaolang101.github.io/2016/08/01/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%92%8C%E6%A0%88%EF%BC%88What%20is%20the%20Execution%20Context%20&amp;%20Stack%20in%20JavaScript%EF%BC%89/" target="_blank" rel="external">深入探讨JavaScript的执行环境和栈</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;执行环境-execution-context&quot;&gt;&lt;a href=&quot;#执行环境-execution-context&quot; class=&quot;headerlink&quot; title=&quot;执行环境 (execution context)&quot;&gt;&lt;/a&gt;执行环境 (execution co
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript - 基础类型&amp;引用类型</title>
    <link href="http://yoursite.com/2017/09/01/JavaScript%20-%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B&amp;%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/09/01/JavaScript - 基础类型&amp;引用类型/</id>
    <published>2017-09-01T09:43:17.000Z</published>
    <updated>2017-09-02T08:58:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 的变量包含两种类型的值 — <strong>基础类型</strong> 和 <strong>引用类型</strong>：</p>
<ul>
<li><strong>基础类型</strong> 包含的数据类型有: <code>Undefined</code> <code>Null</code> <code>Boolean</code> <code>Number</code> <code>String</code> <code>Symbol(ES6 新添加的)</code>。</li>
<li><strong>引用类型</strong> 指的是所有 <code>Object</code> 对象 和 所有派生自 <code>Object</code> 的对象。</li>
</ul>
<h1 id="基础类型、引用类型的区别"><a href="#基础类型、引用类型的区别" class="headerlink" title="基础类型、引用类型的区别"></a>基础类型、引用类型的区别</h1><p>了解 <strong>基础类型</strong> 和 <strong>引用类型</strong> 一些不同的特性特点，才能避免在实际使用中掉进坑里。下面总结了 <strong>基础类型</strong> 和 <strong>引用类型</strong> 的区别，后面再通过一些例子和图片细说这些区别:</p>
<ul>
<li><strong>基础类型</strong> 存储在 <strong>栈内存区</strong> 中 <strong>按值访问</strong> 的。</li>
<li><strong>引用类型</strong> 存储在 <strong>堆内存区</strong> 中 <strong>按引用访问</strong> 的。</li>
<li><strong>基础类型</strong> 大小确定，不能改变。</li>
<li><strong>引用类型</strong> 大小不定，可以改变。</li>
<li><strong>基础类型</strong> 赋值时会复制一份 <strong>实际值</strong> 放到对应变量中。</li>
<li><strong>引用类型</strong> 赋值时会复制一份 <strong>引用值</strong> 放到对应的变量中。</li>
<li><strong>基础类型</strong> 进行对比时，对比的是实际的值。</li>
<li><strong>引用类型</strong> 进行对比时，对比的是引用。</li>
</ul>
<h1 id="基础类型和引用类型在内存中的分布"><a href="#基础类型和引用类型在内存中的分布" class="headerlink" title="基础类型和引用类型在内存中的分布"></a>基础类型和引用类型在内存中的分布</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message1 = <span class="string">'ni hao ya'</span>;</div><div class="line"><span class="keyword">var</span> person1  = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'奥观海'</span>,</div><div class="line">  <span class="attr">height</span>: <span class="number">185</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码块中声明了两个变量，<code>message1</code> 里装着 <strong>String - 基础类型</strong> 的值，<code>person1</code> 里装装着 <strong>Object 引用类型</strong>。下面通过内存分布图形象的说明他们在内存中的分布:</p>
<p><img src="http://ol972cch2.bkt.clouddn.com/javascript_memory_stack_heap_1.png" alt="Artboard - 1"></p>
<p>上图可以看出 <strong>基础类型</strong> 值 <code>ni hao ya</code>  是直接保存在 <strong>栈内存区</strong> 的，可以直接通过 <code>message1</code> 访问它。 而 <strong>引用类型</strong> 值 <code>{name: &#39;奥观海&#39; ...}</code> 是保存在 <strong>堆内存区</strong>，在 <strong>栈内存区</strong> 保存的是这个对象的引用，<code>person1</code> 是通过这个引用去访问位于 <strong>堆内存区</strong> 的对象。所以说 <strong>基础类型</strong> 是按值访问的，而 <strong>引用类型</strong> 是按引用访问的。</p>
<h1 id="改变基础类型和引用类型的值"><a href="#改变基础类型和引用类型的值" class="headerlink" title="改变基础类型和引用类型的值"></a>改变基础类型和引用类型的值</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message1 = <span class="string">'ni hao ya'</span>;</div><div class="line">message1.toUpperCase(); <span class="comment">// 返回: NI HAO YA</span></div><div class="line"><span class="built_in">console</span>.log(message1);  <span class="comment">// 输出: ni hao ya</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person1  = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'奥观海'</span>,</div><div class="line">  <span class="attr">height</span>: <span class="number">185</span></div><div class="line">&#125;</div><div class="line">person1.nation = <span class="string">'肯尼亚'</span>;</div><div class="line"><span class="built_in">console</span>.log(person1);   <span class="comment">// 输出: &#123; name: '奥观海', height: 185, nation: '肯尼亚' &#125;</span></div></pre></td></tr></table></figure>
<p>上面的代码块中 <code>message1</code> 调用 <code>toUpperCase()</code> 方法来把字符串 <code>ni hao ya</code> 转换成大写，但是后面打印 <code>message1</code> 的值仍然是小写的内容，因为 <strong>基础类型</strong> 的值是不能改变，大小确定的。<code>toUpperCase()</code> 方法只是返回了一个新的字符串，并没有改变 <code>message1</code> 变量里 <strong>基础类型</strong> 的值。而对 <code>person1</code> 添加了一个 <code>nation</code> 属性，后面打印时已经看到它的改变了，因此 <strong>引用类型</strong> 是可以改变，大小不定的。下图展示的是操作后的内存分布图：</p>
<p><img src="http://ol972cch2.bkt.clouddn.com/javascript_memory_stack_heap_2.png" alt="Artboard - 2"></p>
<h1 id="基础类型和引用类型进行赋值"><a href="#基础类型和引用类型进行赋值" class="headerlink" title="基础类型和引用类型进行赋值"></a>基础类型和引用类型进行赋值</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message1 = <span class="string">'ni hao ya'</span>;</div><div class="line"><span class="keyword">var</span> message2 = message1;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1  = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'奥观海'</span>,</div><div class="line">  <span class="attr">height</span>: <span class="number">185</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person2 = person1;</div></pre></td></tr></table></figure>
<p>下图展示的是上面代码块执行后的内存分布图:</p>
<p><img src="http://ol972cch2.bkt.clouddn.com/javascript_memory_stack_heap_3.png" alt="Artboard - 3"></p>
<p>上面的代码块把 <code>message1</code> 变量的具体值赋值给了 <code>message2</code> 变量中，<code>message1</code> 和 <code>message2</code> 中都保存了相同的值 <code>ni hao ya</code>。把 <code>person1</code> 变量中的具体值赋值给了<code>person2</code>。 <code>person1</code> 和 <code>person2</code> 中都保存着相通的引用。这就是上面的说 <strong>基础类型</strong> 赋值时会复制一份 <strong>实际值</strong> 放到对应变量中，<strong>引用类型</strong> 赋值时会赋值一份 <strong>引用值</strong> 放到对应的变量中。这会造成一个现象: <code>message1</code> <code>message2</code> 的是相互独立的，修改 <code>message2</code> 并不会影响到 <code>message1</code>。<code>person1</code> <code>person2</code> 的引用是指向同一个对象的，所以修改 <code>person1</code> 也会影响到 <code>person2</code>。下面通过代码去验证这个说法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message1 = <span class="string">'ni hao ya'</span>;</div><div class="line"><span class="keyword">var</span> message2 = message1;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1  = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'奥观海'</span>,</div><div class="line">  <span class="attr">height</span>: <span class="number">185</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person2 = person1;</div><div class="line"></div><div class="line">message2 = <span class="string">'hou hui you qi'</span>;</div><div class="line"><span class="built_in">console</span>.log(message1);  <span class="comment">// 输出: ni hao ya</span></div><div class="line"><span class="built_in">console</span>.log(message2);  <span class="comment">// 输出: hou hui you qi</span></div><div class="line"></div><div class="line">person2.nation = <span class="string">'肯尼亚'</span>;</div><div class="line"><span class="built_in">console</span>.log(person1);   <span class="comment">// 输出: &#123; name: '奥观海', height: 185, nation: '肯尼亚' &#125;</span></div><div class="line"><span class="built_in">console</span>.log(person2);   <span class="comment">// 输出: &#123; name: '奥观海', height: 185, nation: '肯尼亚' &#125;</span></div></pre></td></tr></table></figure>
<p>下图展示的是上面代码块执行后的内存分布图:</p>
<p><img src="http://ol972cch2.bkt.clouddn.com/javascript_memory_stack_heap_4.png" alt="Artboard - 4"></p>
<h1 id="基础类型和引用类型的比较不同"><a href="#基础类型和引用类型的比较不同" class="headerlink" title="基础类型和引用类型的比较不同"></a>基础类型和引用类型的比较不同</h1><p><strong>基础类型</strong> 进行对比时，对比的是实际的值，<strong>引用类型</strong> 进行对比时，对比的是引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message1 = <span class="string">'ni hao ya'</span>;</div><div class="line"><span class="keyword">var</span> message2 = <span class="string">'ni hao ya'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1  = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'奥观海'</span>,</div><div class="line">  <span class="attr">height</span>: <span class="number">185</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person2  = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'奥观海'</span>,</div><div class="line">  <span class="attr">height</span>: <span class="number">185</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(message1 === message2);	<span class="comment">// 输出: true</span></div><div class="line"><span class="built_in">console</span>.log(person1 === person2);	<span class="comment">// 输出: false</span></div></pre></td></tr></table></figure>
<p>下图展示的是上面代码块执行后的内存分布图:</p>
<p><img src="http://ol972cch2.bkt.clouddn.com/javascript_memory_stack_heap_5.png" alt="Artboard - 5"></p>
<p><code>message1</code> <code>message2</code> 是 <strong>基础类型</strong>，所以它们比对的是实际的值，因为都是 <code>ni hao ya</code> 所以返回 true。<code>person1</code> <code>person2</code> 是 <strong>引用类型</strong>，所以它们比对的是引用。<code>person1</code> <code>person2</code> 虽然各自拥有的对象是一模一样的，但是在 <strong>堆内存区</strong> 中它们是两个独立的对象，由不同的引用指向它们。所以返回的是 false。</p>
<h1 id="致敬-参考内容"><a href="#致敬-参考内容" class="headerlink" title="致敬 - 参考内容"></a>致敬 - 参考内容</h1><ul>
<li><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="external">《JavaScript 高级程序设计》</a></li>
<li><a href="https://www.w3cplus.com/javascript/variable-value-data-types.html" target="_blank" rel="external">JavaScript的变量：变量值的数据类型</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 的变量包含两种类型的值 — &lt;strong&gt;基础类型&lt;/strong&gt; 和 &lt;strong&gt;引用类型&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基础类型&lt;/strong&gt; 包含的数据类型有: &lt;code&gt;Undefined&lt;/cod
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript - 声明变量</title>
    <link href="http://yoursite.com/2017/08/29/JavaScript%20-%20%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2017/08/29/JavaScript - 声明变量/</id>
    <published>2017-08-29T15:40:44.000Z</published>
    <updated>2017-09-02T08:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-变量的松散特性"><a href="#JavaScript-变量的松散特性" class="headerlink" title="JavaScript 变量的松散特性"></a>JavaScript 变量的松散特性</h1><p>JavaScript 的变量和其他语言相比有一个很大的区别就是 JavaScript 变量的松散特性，JavaScript 的变量在声明时不需要指定类型。在变量的生命周期内，变量可以任意的改变成任何类型的值。例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> box;</div><div class="line">box = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(box);   <span class="comment">// 输出: 100</span></div><div class="line">box = <span class="string">"吃了吗?"</span>;</div><div class="line"><span class="built_in">console</span>.log(box);   <span class="comment">// 输出: 吃了吗?</span></div><div class="line">box = &#123;<span class="attr">name</span>: <span class="string">'奥观海'</span>, <span class="attr">nation</span>:<span class="string">'肯尼亚'</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(box);   <span class="comment">// 输出: &#123; name: '奥观海', nation: '肯尼亚' &#125;</span></div></pre></td></tr></table></figure>
<p>上面的例子声明了一个 <code>box</code> 变量，先后赋值了 <code>Number</code>、<code>String</code>、<code>Object</code> 类型的值，都可以正常使用。</p>
<h1 id="声明变量-常量的-let、const、var"><a href="#声明变量-常量的-let、const、var" class="headerlink" title="声明变量/常量的 let、const、var"></a>声明变量/常量的 let、const、var</h1><p>JavaScript 中声明一个 变量/常量 可以使用的关键字有 <code>let</code> <code>const</code> <code>var</code> ，下面总结了它们的特点和区别:</p>
<h3 id="变量常量"><a href="#变量常量" class="headerlink" title="变量常量"></a>变量常量</h3><p><code>var</code> 和 <code>let</code>  关键字声明的是 <strong>变量</strong>，赋值后可以再次修改它的值。 <code>const</code> 关键字声明的是 <strong>常量</strong>，声明时必须初始化，并且赋值后就不能再修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> var_box = <span class="number">100</span>;</div><div class="line"><span class="keyword">let</span> let_box = <span class="number">200</span>;</div><div class="line"><span class="keyword">const</span> const_box1 = <span class="number">300</span>;</div><div class="line"><span class="keyword">const</span> const_box2;	<span class="comment">// 报错: Missing initializer in const declaration</span></div><div class="line"></div><div class="line">var_box = <span class="number">101</span>;</div><div class="line">let_box = <span class="number">201</span>;</div><div class="line">const_box = <span class="number">301</span>;  	<span class="comment">// 报错: Assignment to constant variable.</span></div></pre></td></tr></table></figure>
<h3 id="var的变量提升"><a href="#var的变量提升" class="headerlink" title="var的变量提升"></a>var的变量提升</h3><p><code>var</code> 声明的变量有变量提升的特性，而 <code>let</code> <code>const</code> 变量/常量 则没有。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(var_box);		<span class="comment">// 输出 undefined</span></div><div class="line"><span class="built_in">console</span>.log(let_box); 		<span class="comment">// 报错: let_box is not defined</span></div><div class="line"><span class="built_in">console</span>.log(const_box); 	<span class="comment">// 报错: const_box is not defined</span></div><div class="line">  </div><div class="line"><span class="keyword">var</span> var_box = <span class="number">100</span>;</div><div class="line"><span class="keyword">let</span> let_box = <span class="number">200</span>;</div><div class="line"><span class="keyword">const</span> const_box = <span class="number">300</span>;</div></pre></td></tr></table></figure>
<p>上面的例子，在  <code>var_box</code> 变量的声明之前访问它不会报错，得到的值是 <code>undefined</code> 。以同样的方式访问声明前的 <code>let_box</code>  <code>const_box</code> 则会报错。这是因为解析器对 <code>var</code> 声明的变量进行了变量提升，上面的代码可以等同于下面代码: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> var_box;</div><div class="line"><span class="built_in">console</span>.log(var_box);		<span class="comment">// 输出 undefined</span></div><div class="line"><span class="built_in">console</span>.log(let_box); 		<span class="comment">// 报错: let_box is not defined</span></div><div class="line"><span class="built_in">console</span>.log(const_box); 	<span class="comment">// 报错: const_box is not defined</span></div><div class="line">  </div><div class="line">var_box = <span class="number">100</span>;</div><div class="line"><span class="keyword">let</span> let_box = <span class="number">200</span>;</div><div class="line"><span class="keyword">const</span> const_box = <span class="number">300</span>;</div></pre></td></tr></table></figure>
<h3 id="变量-常量-的作用域"><a href="#变量-常量-的作用域" class="headerlink" title="变量/常量 的作用域"></a>变量/常量 的作用域</h3><p><code>var</code> 声明的变量的有效作用域为 <strong>全局作用域</strong> 和 <strong>函数作用域</strong>，而 <code>let</code> <code>const</code> 声明的变量/常量 的有效作用域除了 <strong>全局作用域</strong> 和 <strong>函数作用域</strong> 还包括更小的 <strong>块级作用域</strong>。例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test_func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">var</span> var_box = <span class="number">100</span>;</div><div class="line">    <span class="keyword">let</span> let_box = <span class="number">200</span>;</div><div class="line">    <span class="keyword">const</span> const_box = <span class="number">300</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 三个变量/常量 全部都能访问到，输出 100, 200, 300</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;var_box&#125;</span>, <span class="subst">$&#123;let_box&#125;</span>, <span class="subst">$&#123;const_box&#125;</span>`</span>); </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="built_in">console</span>.log(var_box);		<span class="comment">// 输出 100</span></div><div class="line">  <span class="built_in">console</span>.log(let_box); 	<span class="comment">// 报错: let_box is not defined</span></div><div class="line">  <span class="built_in">console</span>.log(const_box);   <span class="comment">// 报错: const_box is not defined</span></div><div class="line">&#125;</div><div class="line">test_func();</div></pre></td></tr></table></figure>
<p>因为 <code>let</code> <code>cosnt</code>  声明的变量/常量的最小有效作用域为 <strong>块级作用域</strong> 所以在 <strong>if - 块级作用域</strong> 声明的变量/常量超出了这个 <strong>块级作用域</strong> 就访问不到了。而 <code>var</code> 定义的变量最小作用域为 <strong>函数作用域</strong> ，即使是在 <strong>if - 块级作用域</strong> 中定义的 <code>var</code> 变量，但 <strong>块级作用域</strong> 对它没有效果，所以在整个 <strong>test_func - 函数作用域</strong> 中都有效。超出 <strong>test_func - 函数作用域</strong> 则访问不到。</p>
<h3 id="全局变量-amp-局部变量"><a href="#全局变量-amp-局部变量" class="headerlink" title="全局变量 &amp; 局部变量"></a>全局变量 &amp; 局部变量</h3><p><strong>全局变量</strong> 的有效作用域是 <strong>全局作用域</strong>，定义在所有的函数的外面，整个 Javascript 程序的生命周中都可以使用。 <strong>局部变量</strong> 的有效作用域为 <strong>函数作用域</strong> 或 <strong>块级作用域</strong>，超出了对应作用域就访问不到了。但是 JavaScript 中还有一种特殊的方式声明 <strong>全局变量</strong>，就是在 <strong>函数作用域/块级作用域</strong> 直接使用变量，不写 <code>var</code> 或 <code>let</code> 关键字，这样的变量就是 <strong>全局变量</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test_func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  box = <span class="number">100</span>;</div><div class="line">&#125;</div><div class="line">test_func();</div><div class="line"><span class="built_in">console</span>.log(box);  <span class="comment">// 输出 100</span></div></pre></td></tr></table></figure>
<p>上面例子中没有声明 <code>box</code> 变量直接使用，解析器就把它当做了全局变量，在浏览器中可以通过 <code>window.box</code>  获得。所以超出 <strong>test_fucn - 函数作用域</strong> 仍然可以访问。不过实际使用时并不推荐这种方式。需要防止忘了写 <code>var</code> <code>let</code> 让变量变成了 <strong>全局变量</strong>， 导致程序实现和自己的想法有出入。</p>
<blockquote>
<p> <strong>注：</strong>这种方式在 <code>use strict</code> 严格模式下会报错 <code>is not defined</code>。</p>
</blockquote>
<h3 id="ECMAScript-支持版本"><a href="#ECMAScript-支持版本" class="headerlink" title="ECMAScript 支持版本"></a>ECMAScript 支持版本</h3><p><code>let</code> 关键字是 ES6 提供的变量声明方法，它和 <code>var</code> 关键字的作用非常相似，但 <code>let</code> 关键字支持更符合我们思维习惯的 <strong>块级作用域</strong>，所以在不需要兼容 ES6 以前的环境时(例: Node) 推荐使用 <code>let</code> 关键字去替代 <code>var</code> 关键字。</p>
<h1 id="致敬-参考内容"><a href="#致敬-参考内容" class="headerlink" title="致敬 - 参考内容"></a>致敬 - 参考内容</h1><ul>
<li><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="external">《JavaScript 高级程序设计》</a></li>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6 入门 - let 和 const 命令</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript-变量的松散特性&quot;&gt;&lt;a href=&quot;#JavaScript-变量的松散特性&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 变量的松散特性&quot;&gt;&lt;/a&gt;JavaScript 变量的松散特性&lt;/h1&gt;&lt;p&gt;JavaSc
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript - 前世今生</title>
    <link href="http://yoursite.com/2017/07/03/JavaScript%20-%20%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://yoursite.com/2017/07/03/JavaScript - 前世今生/</id>
    <published>2017-07-03T12:27:55.000Z</published>
    <updated>2017-09-02T08:59:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-的历史-amp-版本"><a href="#JavaScript-的历史-amp-版本" class="headerlink" title="JavaScript 的历史&amp;版本"></a>JavaScript 的历史&amp;版本</h1><p>📆 1994年12月 - 网景公司(Netscape) 发布了Navigator浏览器1.0版，市场份额一举超过了90%。</p>
<blockquote>
<p><strong>注:</strong>  后来 Netscape 公司很快发现， Navigator 浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器的行为。比如说网页上有一个表单需要用户自己填写名称，那么浏览器无法知道用户是否真的填写了用户名称，而是需要将信息发送到服务器端才能判断，若用户没有填写，只能等待服务器返回错误信息，这十分浪费服务器资源与用户的时间。</p>
</blockquote>
<p>📆 1995年05月 - Netscap 公司的 Brendan Eich 只用了10天就设计完成了这种语言的第一版。叫做 Mocha。</p>
<p>📆 1995年09月 - Mocha 改名为 LiveScript。</p>
<p>📆 1995年12月 - Netscap 公司为了借助 Java 语言的声势， 将 LiveScript 改名为 JavaScript 。其实关系不大。</p>
<p>📆 1996年03月 - Navigator 2.0 浏览器正式内置了 JavaScript 语言。</p>
<p>📆 1996年08月 - 微软模仿 JavaScript 语言开发了一种相近的语言(JScript) 内置在 IE 3.0 中。与 JavaScript 竞争。</p>
<p>📆 1996年11月 - Netscape 公司将 JavasScript 提交给国际组织 ECMA 进行标准化，以此来应对微软的挑战。ECMA 的39号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成。</p>
<p>📆 1997年07月 - ECMA 组织发布262号标准文件（ECMA-262）的第一版，规定浏览器脚本语言的标准，并将这种语言称为ECMAScript。这个版本就是ECMAScript 1.0版。</p>
<blockquote>
<p><strong>注:  JavaScript 和 ECMAScript 的关系 ?</strong></p>
<p>发布了 ECMAScript 后由于 JavaScript 名字的历史原因和市场原因，现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。 所以 ECMAScript 指的是标准，而 JavaScript 指的是实现</p>
<ul>
<li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li>
<li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li>
</ul>
</blockquote>
<p>📆 1998年06月 - ECMAScript 2.0 版发布。</p>
<p>📆 1999年12月 - ECMAScript 3.0 版发布，成为 JavaScript 的通行标准得到了广泛支持。</p>
<p>📆 2007年10月 - ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级，但是 4.0 版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。</p>
<p>📆 2008年07月 - 由于 TC39 委员会内部各方对于 4.0 版本的内容分歧太大，为了避免陷入僵局，委员进行了一场会晤，会议达成以下内容:</p>
<ul>
<li>废除 4.0 版本，将其中涉及现有功能改善的一小部分发布为 ECMAScript 3.1（后来改名为 ECMAScript 5.0）</li>
<li>其他的一些激进的设想放入以后的版本，项目代号为 Harmony（和谐）</li>
</ul>
<p>📆 2009年12月 - ECMAScript 5.0 版正式发布。</p>
<blockquote>
<p><strong>注：</strong> 后来 Harmony 项目被一分为二：</p>
<ul>
<li>一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6</li>
<li>一些不是很成熟的设想则被视为 JavaScript.next.next， 在更远的将来再考虑推出。</li>
</ul>
</blockquote>
<p>📆 2011年06月 - ECMAscript 5.1 版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持ECMAScript 5.1 版的全部功能。</p>
<p>📆 2013年03月 - ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。</p>
<p>📆 2013年12月 - ECMAScript 6 草案发布。然后是12个月的讨论期，听取各方反馈。</p>
<p>📆 2015年06月 - ECMAScript 6 正式发布，并且更名为”ECMAScript 2015”。</p>
<blockquote>
<p><strong>注:  ES6  和  ECMAScript 2015 是什么关系 ?</strong></p>
<p>ECMAScript  TC39 委员会决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此: </p>
<p>ECMAScript 6 = ES6 = ECMAScript 2015 = ES2015 。</p>
<p>ECMAScript 7 = ES7 = ECMAScript 2016 = ES2016 。</p>
</blockquote>
<h3 id="Mozilla-的-JavaScript-版本号"><a href="#Mozilla-的-JavaScript-版本号" class="headerlink" title="Mozilla 的 JavaScript 版本号"></a>Mozilla 的 JavaScript 版本号</h3><p>有时会看到t特殊的 JavaScript 1.5 或 JavaScript 1.8 的版本号， 这些是 Netscape公司（以及继承它的Mozilla基金会）在内部依然使用自己的版本号。这导致了JavaScript有自己不同于ECMAScript的版本号。Mozilla的版本号：</p>
<ul>
<li>JavaScript 1.1 版对应 ECMAScript 1.0 ，但是直到 JavaScript 1.4版才完全兼容ECMAScript 1.0</li>
<li>JavaScript 1.5 版完全兼容 ECMAScript 3.0。</li>
<li>JavaScript 1.8 版完全兼容 ECMAScript 5。</li>
</ul>
<h1 id="致敬-参考内容"><a href="#致敬-参考内容" class="headerlink" title="致敬 - 参考内容"></a>致敬 - 参考内容</h1><ul>
<li><a href="http://JavaScript.ruanyifeng.com/introduction/history.html" target="_blank" rel="external">JavaScript语言的历史 - 阮一峰</a></li>
<li><a href="https://huangxuan.me/2015/09/22/js-version/" target="_blank" rel="external">ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」</a></li>
<li><a href="http://www.cnblogs.com/ziyunfei/archive/2012/09/24/2699065.html" target="_blank" rel="external">译: ECMAScript:ES.next和ES6以及ES Harmony之间的区别 - 紫云飞</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript-的历史-amp-版本&quot;&gt;&lt;a href=&quot;#JavaScript-的历史-amp-版本&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 的历史&amp;amp;版本&quot;&gt;&lt;/a&gt;JavaScript 的历史&amp;amp;版本&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>更安全的 HTTP Part1 - HTTP的安全隐患</title>
    <link href="http://yoursite.com/2017/05/11/%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%20HTTP%20Part1%20-%20HTTP%E7%9A%84%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/"/>
    <id>http://yoursite.com/2017/05/11/更安全的 HTTP Part1 - HTTP的安全隐患/</id>
    <published>2017-05-11T08:17:24.000Z</published>
    <updated>2017-05-12T12:05:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>现今很多的 <strong>WEB 应用</strong> 依赖于 <strong>HTTP 协议</strong>，<strong>HTTP</strong> 作为服务端和客户端沟通的桥梁，帮这个世界构建了数不清的精彩 <strong>WEB 应用</strong>。 但是 <strong>HTTP 协议</strong> 是明文传输的，敏感数据例如密码，金额等等，如果不加特殊处理会有很大的安全隐患。下面就来谈谈使用 <strong>HTTP 协议</strong> 可能面临的安全隐患。</p>
<h1 id="明文传输-传输内容被监听"><a href="#明文传输-传输内容被监听" class="headerlink" title="明文传输 - 传输内容被监听"></a>明文传输 - 传输内容被监听</h1><p>默认的通过  <strong>HTTP 协议</strong> 传输的内容都是明文传输，不经过任何加密的。如果 <strong>HTTP 报文</strong> 中含有密码，直接就可以通过抓包工具来看到密码内容。更严重的是网络传输中要经历很多个节点，所有经过的节点都会知道访问的网站URL、用户名和密码，等同于整个账号被泄漏。</p>
<h4 id="对密码进行加密"><a href="#对密码进行加密" class="headerlink" title="对密码进行加密"></a>对密码进行加密</h4><p>对密码进行 <code>对称</code> 或者 <code>非对称</code> 加密处理其实也解决不了根本问题。对密码加密后的密文在网络上传输仍然会被截获，虽然不能通过密文反推出原始密码，可是截获方可以直接发送加密后的密文给服务端效果是相同的。服务端并不能区分是谁发送，只要接收到的密文解密后和数据库里存储的密码相同就被认定通过了。这种被称为 <code>重放攻击</code> 。</p>
<h4 id="通过加入随机数来避免重放攻击"><a href="#通过加入随机数来避免重放攻击" class="headerlink" title="通过加入随机数来避免重放攻击"></a>通过加入随机数来避免重放攻击</h4><p>通过一个一定时间段有效(比如1分钟) 的随机数 + 密码来组成一个字符串并加密，所得出的密文来传输给服务端可以一定程度来避免 <code>重放攻击</code> 的问题，但是还是有瑕疵。因为服务器必须知道随机数的数值，所以随机数是通过服务器生成并传给客户端的，所以会多出传送随机数的步骤。并且在随机数有效的时间里(比如1分钟)，不怀好意的人还是能够使用 <code>重放攻击</code>。</p>
<h4 id="加密整个-HTTP-来避免被监听"><a href="#加密整个-HTTP-来避免被监听" class="headerlink" title="加密整个 HTTP 来避免被监听"></a>加密整个 HTTP 来避免被监听</h4><p>除了上面的方法，还可以通过加密整个 <strong>HTTP 报文</strong> 来防止传输内容被监听。考虑客户端的密钥很容易被窃取，所以这里使用非对称加密算法 <code>RSA</code> 更合适。但是对整个 <strong>HTTP 报文</strong> 加密会有很大的效率问题。<code>RSA</code> 非对称算法的加密速度相对对称算法非常慢，并且解密速度相对 <code>RSA</code> 的加密速度来讲也是非常慢。所以对整个报文都进行 <code>RSA</code> 加密，数据量大了后会给服务端带来很大压力。</p>
<h1 id="中间人攻击-报文被篡改"><a href="#中间人攻击-报文被篡改" class="headerlink" title="中间人攻击 - 报文被篡改"></a>中间人攻击 - 报文被篡改</h1><p><strong>HTTP 协议</strong> 默认是不能验证报文的完整性的，当在两个端传递数据时，中间经过的节点可以修改报文的内容，当传递到另一端的时候报文内容已经遭到篡改。例如，客户端请求转一笔钱给 A 用户，但是在传递的过程中被其中的一个节点修改成 B 用户，这就有很大的安全隐患。还有一种最常见的 <strong>运营商劫持</strong>，我们经常在网上的右下角会看到一个方形的广告，这其实在很多时候都不是网页提供方做的。而是运营商为了利益修改了返回报文，在其中加入的广告。</p>
<h1 id="不能验证通信方的身份"><a href="#不能验证通信方的身份" class="headerlink" title="不能验证通信方的身份"></a>不能验证通信方的身份</h1><p><strong>HTTP 协议</strong> 并不能验证通信双方的真实身份，比如客户端并不能验证服务端是否是被伪造，还是会一直和服务端去发送请求。这就有可能被服务端窃取到一些敏感数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现今很多的 &lt;strong&gt;WEB 应用&lt;/strong&gt; 依赖于 &lt;strong&gt;HTTP 协议&lt;/strong&gt;，&lt;strong&gt;HTTP&lt;/strong&gt; 作为服务端和客户端沟通的桥梁，帮这个世界构建了数不清的精彩 &lt;strong&gt;WEB 应用&lt;/strong&gt;。 但
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Sketch 初体验</title>
    <link href="http://yoursite.com/2017/04/30/Sketch%20%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2017/04/30/Sketch 初体验/</id>
    <published>2017-04-30T02:14:41.000Z</published>
    <updated>2017-04-30T10:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一款壁纸的小App。因为要画设计图，所以就使用了鼎鼎大名的 Sketch 。Sketch 是一款矢量绘图设计工具非常适合做 UI，它使用简单上手贼快并且能满足日常需求，能够做 App的界面设计和 ICON 设计。Sketch 本身带了不少移动端的 UI 控件视图，这样大大提高了效率，作为会一点 iOS 的程序员使用过程中有种在使用 <code>Storyboard</code> 的错觉。</p>
<h1 id="使用界面"><a href="#使用界面" class="headerlink" title="使用界面"></a>使用界面</h1><p><img src="http://ol972cch2.bkt.clouddn.com/Sketch%20UI%20Shot.png" alt="Sketch 截图"></p>
<p><strong>1. 菜单栏</strong>和所有软件一样，包含了这个软件的大部分操作，也可以通过快捷键去代替的一部分操作</p>
<p><strong>2. 工具栏</strong>包含了创作过程中所需要的工具，比如 <code>Insert</code> 来添加文本、图片、图层等等，<code>Group/Ungroup</code> 来组合和拆分多个视图，一组绿色的按钮是一系列<strong>形变工具</strong>，最后一排蓝色的是为多个图形做<strong>布尔运算</strong> </p>
<p><strong>3. 图层列表</strong>是整个工程的目录，它列出了当前工程里的所有页面，每个页面里面又包含着Artboard和视图，每个视图都有一个小预览。在<strong>图层列表</strong>中可以锁定视图防止其被更改，或者隐藏视图。也可以调整视图层级，对视图进行分组和重命名来管理他们。</p>
<p><strong>4. 画布</strong>是设计和编辑视图的主要区域，Sketch 画布尺寸是无限的，可以任意方向无限延伸，可以随意来规划自己的创作区域。如果想要在画布中设置一个固定的画框，可以新建一个或者多个新的 <code>Artboard</code> ，设计移动应用界面时一般为每一屏创建一个 <code>Artbaord</code>。</p>
<p><strong>5. 属性检查器</strong>是显示和编辑视图的区域，选中一个视图后右侧的<strong>属性检查器</strong>就会显示其相应的属性。可以对视图进行一些参数调整，比如透明度、位置、颜色、字体等等，还能设置边框、阴影和模糊效果。</p>
<h1 id="使用-Artboard-构建一个简单-App-页面"><a href="#使用-Artboard-构建一个简单-App-页面" class="headerlink" title="使用 Artboard 构建一个简单 App 页面"></a>使用 Artboard 构建一个简单 App 页面</h1><h3 id="1-创建合适-Artboard"><a href="#1-创建合适-Artboard" class="headerlink" title="1. 创建合适 Artboard"></a>1. 创建合适 Artboard</h3><p>上面提到过在无限尺寸的画布中一般为每一个屏幕创建一个 <code>Artboard</code>，然后在里面去构建一个 App 页面，多个 <code>Artbaord</code> 组合在一起就是一个完整的 App 设计图了。新建一个工程后，点击 <code>Artboard</code> 然后右侧的<strong>属性检查器</strong>就会显示一些常见预设的尺寸，比如 iPhone7、 7Plus、iPad 等等，点击 iPhone7 画布上会显示对应大小的 <code>Artboard</code> ，然后就可以在里面设计内容了</p>
<p><img src="http://ol972cch2.bkt.clouddn.com/Artboard%20iPhone4.7.png" alt="Artboard iPhone7"></p>
<h3 id="2-使用自带的控件提高效率"><a href="#2-使用自带的控件提高效率" class="headerlink" title="2. 使用自带的控件提高效率"></a>2. 使用自带的控件提高效率</h3><p>Sketch 自带了很多各个平台的控件视图，直接使用这些自带的控件视图非常方便，能够快速的画出一个 App 的页面。选择 <code>File</code> → <code>New From Template</code> → <code>iOS UI Design</code> 会新建一个工程，里面包含了 iOS 平台常用的视图。比如状态栏、NavigationBar、键盘等等。把想要使用的控件视图复制然后粘贴到刚才的 iPhone7 的 <code>Artboard</code> 中，利用这些现成的控件视图可以很快拼接出一个 App 界面，就像使用 <code>Storyboard</code> 那样，下面是一个用户的个人信息页面。</p>
<p><img src="http://ol972cch2.bkt.clouddn.com/artboard_user_info.png" alt=""></p>
<h3 id="3-导出设计图"><a href="#3-导出设计图" class="headerlink" title="3. 导出设计图"></a>3. 导出设计图</h3><p>完成了一个简单的 App 页面的设计后，点击这个 <code>Artboard</code> 然后软件的右下角就会显示 <code>Export</code> 一栏，选择要导出的大小后和格式后，点击 <code>Export</code> 按钮就可以把设计图导出成想要的格式，然后就可以把导出的文件发给程序员或者其他人了。至此完成了构建一个简单的 App 界面的所有过程。</p>
<h1 id="使用-Symbol-和-Style-避免重复工作"><a href="#使用-Symbol-和-Style-避免重复工作" class="headerlink" title="使用 Symbol 和 Style 避免重复工作"></a>使用 Symbol 和 Style 避免重复工作</h1><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p><code>Symbol</code> 可以定义一个视图，然后在工程里的任意地方直接可以直接复用这个视图。如果这个 <code>Symbol</code> 视图发生了变更工程里的所有用到这个 <code>Symbol</code> 视图都会一起发生变化。只需要选中一个或者一组视图然后点击 <code>Carete Symbol</code> 按钮就可以创建一个 <code>Symbol</code> 视图，然后在 <code>Insert</code> → <code>Symbol</code> 列表中就能看到这个创建的 <code>Symbol</code> 视图，点击即可在画布中创建一个 <code>Symbol</code> 的视图。</p>
<h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><p><code>Style</code> 很像 CSS 样式表，它保存的是视图或者文本的样式属性，比如颜色、文字大小、阴影等等属性。设计好一个视图后选中视图，点击 <code>Create New Shared Style</code> 按钮就创建了一个 <code>Style</code> ，然后再选中其他视图套用刚才创建的 <code>Style</code> 立马就应用了和第一个视图一模一样的属性。同样的更新 <code>Style</code> 的属性后，所有应用了这个 <code>Style</code> 的视图都会立马发生相应的改变。</p>
<h1 id="Sketch-的支持工具"><a href="#Sketch-的支持工具" class="headerlink" title="Sketch 的支持工具"></a>Sketch 的支持工具</h1><h3 id="Sketch-ToolBox"><a href="#Sketch-ToolBox" class="headerlink" title="Sketch ToolBox"></a>Sketch ToolBox</h3><p>Sketch 支持拓展插件，而 <code>Sketch ToolBox</code> 就是一款专门管理 Sketch 插件的软件。可以找一些有用的插件放进自己的工具箱。</p>
<h3 id="Zeplin"><a href="#Zeplin" class="headerlink" title="Zeplin"></a>Zeplin</h3><p>Zeplin 其实也是一个 Sketch 插件，它可以为 Sketch 设计图提供标注。它和 Sketch 无缝衔接，只需要选中 <code>Artboard</code> 然后选择 <code>Plugins</code> → <code>Zeplin</code> → <code>Export Select Artboard</code> 就可以把选中的 <code>Artboard</code> 导入到 <code>Zeplin</code> ，然后就能看到标注了。并且还提供了颜色和字体的代码，直接拷贝到程序中能方便在程序中选择颜色和字体。简直好用到哭，并且还是免费的，再哭一次。</p>
<h3 id="Icon-Font"><a href="#Icon-Font" class="headerlink" title="Icon Font"></a>Icon Font</h3><p><a href="http://iconfont.cn/" target="_blank" rel="external">Icon Font</a> 是一个专门提供图标素材的网站，提供了非常丰富的图标库。并且可以根据文字搜索出对应的图标。App 中绝大部分的图标都有一定的通用性质。只要找到满意的图标就不用苦哈哈的自己去画了，说不定自己画了还没有别人现成的好。在网站下载图标的 SVG 文件，然后直接拖到 Sketch 中就能使用。贼省事。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做一款壁纸的小App。因为要画设计图，所以就使用了鼎鼎大名的 Sketch 。Sketch 是一款矢量绘图设计工具非常适合做 UI，它使用简单上手贼快并且能满足日常需求，能够做 App的界面设计和 ICON 设计。Sketch 本身带了不少移动端的 UI 控件视图，这
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objective-C Block Part3 - Weak-Strong Dance</title>
    <link href="http://yoursite.com/2017/03/30/Objective-C%20Block%20Part3%20-%20Weak-Strong%20Dance/"/>
    <id>http://yoursite.com/2017/03/30/Objective-C Block Part3 - Weak-Strong Dance/</id>
    <published>2017-03-30T05:30:39.000Z</published>
    <updated>2017-03-30T05:31:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Weak-Strong-Dance-？"><a href="#什么是-Weak-Strong-Dance-？" class="headerlink" title="什么是 Weak-Strong Dance ？"></a>什么是 Weak-Strong Dance ？</h2><p>在使用的 <code>Block</code> 时， 除了使用 <code>__weak</code> 修饰符去避免循环引用外，还可以通过名为 <code>Weak-Strong Dance</code> 的方式去避免循环引用。 其实 <code>Weak-Strong Dance</code> 并不是一个新东西，它只是 <code>__weak</code> 的一个升级版本。主要目的是为了避免在极端情况下 <code>__weak</code>  这种情况会出现的问题。</p>
<p><br></p>
<h2 id="使用-weak-形式避免循环引用有什么问题"><a href="#使用-weak-形式避免循环引用有什么问题" class="headerlink" title="使用 __weak 形式避免循环引用有什么问题?"></a>使用 __weak 形式避免循环引用有什么问题?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">typedef void(^blk_t)();</div><div class="line"></div><div class="line">@interface TObject : NSObject</div><div class="line">@property (nonatomic) blk_t block;</div><div class="line">@end</div><div class="line">@implementation TObject</div><div class="line">- (instancetype)init &#123;</div><div class="line">    self = [super init];</div><div class="line">  </div><div class="line">    __weak typeof(self) weakSelf = self;</div><div class="line">    self.block = ^() &#123;</div><div class="line">      NSLog(@&quot;block start...&quot;);</div><div class="line">      NSLog(@&quot;self is %@&quot;, weakSelf);</div><div class="line">      NSLog(@&quot;block   end...&quot;);</div><div class="line">    &#125;;  </div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面这段代码在大部分的情况下都是可行的，Block 捕获 weakSelf。当 self 被释放的时候， weakSelf 也会被设为 <code>nil</code>。self 持有的  Block 当然也会被设为 <code>nil</code> 。但是在多线程的情况当 block 执行到 <code>NSLog(@&quot;block start...&quot;)</code> 时， 在另一个线程中此时 self 被释放。 weakSelf 也被设为 <code>nil</code> 。那么这个例子中就会打印出 <code>self is nil</code> 。这没出现啥问题。 但是如果是移除 KVO 的观察者，或者添加到 NSDictionary 中这样的 API。值为 <code>nil</code> 就会造成程序 carsh。</p>
<p><br></p>
<h2 id="通过-Weak-Strong-Dance-安全的避免循环引用"><a href="#通过-Weak-Strong-Dance-安全的避免循环引用" class="headerlink" title="通过 Weak-Strong Dance 安全的避免循环引用"></a>通过 Weak-Strong Dance 安全的避免循环引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    __weak typeof(self) weakSelf = self;</div><div class="line">    self.block = ^() &#123;</div><div class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">        NSLog(@&quot;%@&quot;, strongSelf);</div><div class="line">    &#125;;   </div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过对上面的代码增加了一句 <code>__strong typeof(weakSelf) strongSelf = weakSelf;</code> 来避免了上面说的极端情况，这就是 <code>Weak-Strong Dance</code> 。 这句话的作用在于一执行 Block 的时候，就利用一个强引用去持有 weakSelf。 这样在 Block 执行的过程中就不用担心 self 会被释放了， 因为此时有个强引用持有他。这也不会造成循环引用，因为 Block 执行时 <code>strongSelf</code> 才会指向 self，Block 执行完成后 <code>strongSelf</code> 就随着超出作用域而被系统回收了。</p>
<p><br></p>
<h2 id="拓展-amp-加深"><a href="#拓展-amp-加深" class="headerlink" title="拓展&amp;加深"></a>拓展&amp;加深</h2><p>在 <a href="http://weibo.com/huangjim?refer_flag=1001030101_&amp;is_all=1" target="_blank" rel="external">@kuailejim</a> 的文章 <a href="http://www.jianshu.com/p/737999a30544" target="_blank" rel="external">Weak-Strong-Dance真的安全吗？》</a> 看到个新的观点: 当刚进入 Block 时还没有为 strongSelf 赋值时，此时 weakSelf 被设置成 <code>nil</code> ，那 strongSelf 的值还是 <code>nil</code> 。 还是不够安全，所以在对 strongSelf 赋值后，再做一次非空判断。这样就绝对没毛病了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">self.block = ^() &#123;</div><div class="line">    __strong typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">    if (strongSelf == nil) &#123;return;&#125;;</div><div class="line">    NSLog(@&quot;%@&quot;, strongSelf);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Weak-Strong-Dance-？&quot;&gt;&lt;a href=&quot;#什么是-Weak-Strong-Dance-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Weak-Strong Dance ？&quot;&gt;&lt;/a&gt;什么是 Weak-Strong D
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objective-C Block Part2 - 实现原理</title>
    <link href="http://yoursite.com/2017/03/30/Objective-C%20Block%20Part2%20-%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/03/30/Objective-C Block Part2 - 实现原理/</id>
    <published>2017-03-30T03:08:08.000Z</published>
    <updated>2017-03-30T03:33:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Block-的本质"><a href="#Block-的本质" class="headerlink" title="Block 的本质"></a>Block 的本质</h2><p>在 <strong><a href="http://tao.bio/2017/03/26/Objective-C%20Block%20Part1%20-%20%E4%BB%8B%E7%BB%8D&amp;%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">Objective-C Block Part1</a></strong>  中总结了 Block 的一些使用规则，但是为什么要遵循这些规则，还有这些规则是怎么来的？ 这就需要探寻 Block 的本质，明白它的实现原理。</p>
<blockquote>
<p><strong>注:</strong>  我们通过 clang 把包含 Block 的 Objective-C 的代码转换成 C++ 实现代码，以此来分析 Block 的实现原理。通过 clang 重写的代码仅供我们分析和参考，在极少数地方和实际运行时有细微出入。</p>
</blockquote>
<p><br></p>
<h4 id="简单-Block-转换后的代码分析"><a href="#简单-Block-转换后的代码分析" class="headerlink" title="简单 Block 转换后的代码分析"></a>简单 Block 转换后的代码分析</h4><p>下面通过 <code>clang -rewrite-objc main.m</code> 把一个简单的 Block 转换成 C++ 代码 <code>main.cpp</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/** 转换前的 Objective-C 代码: */</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    char *name = &quot;Steve Jobs&quot;;</div><div class="line">    ^() &#123;</div><div class="line">        printf(&quot;hello %s :)&quot;, name);</div><div class="line">    &#125;();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 转换后裁剪出的重要代码: */</span></div><div class="line"><span class="keyword">struct</span> __block_impl &#123;</div><div class="line">    <span class="keyword">void</span> *isa;</div><div class="line">    <span class="keyword">int</span> Flags;</div><div class="line">    <span class="keyword">int</span> Reserved;</div><div class="line">    <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  <span class="keyword">char</span> *name;</div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">char</span> *_name, <span class="keyword">int</span> flags=<span class="number">0</span>) : name(_name) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="keyword">char</span> *name = __cself-&gt;name; <span class="comment">// bound by copy</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"hello %s :)"</span>, name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  <span class="keyword">size_t</span> reserved;</div><div class="line">  <span class="keyword">size_t</span> Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> *name = <span class="string">"Steve Jobs"</span>;</div><div class="line">    ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, name))();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>我们看到 Block 的本质其实就是一个名为 <code>__main_block_impl_0</code> 的结构体。这个结构体包含的主要内容:</strong> </p>
<ol>
<li><code>__block_impl</code> 结构体的变量。 (block 结构体的第一个成员都是 <code>__block_impl</code>, 所以 <code>__block_impl</code> 是 block 的基础结构体。</li>
<li><code>__main_block_desc_0</code> 结构体的变量。( <code>__main_block_desc_0</code> 是描述 block 的结构体。</li>
<li><strong>可选的</strong> 被截获的成员，例如本例的 <code>char *name</code> ，这一块下一节细述。</li>
<li><code>__main_block_impl_0</code> 结构体的构造函数</li>
</ol>
<p><br></p>
<p><strong>再来分析一下 <code>__main_block_impl_0</code> 结构体的第一个成员 <code>__block_impl</code> 结构体里的内容:</strong></p>
<ol>
<li><code>void *isa;</code>  (所有的 OC 对象的都有 isa指针，这也说明 Block 是一个 OC 对象。</li>
<li><code>int Flags;</code>  (用于按 bit 位表示一些 block 的附加信息。</li>
<li><code>int Reserved;</code>  (保留变量。</li>
<li><code>void *FuncPtr;</code>  (block 执行的函数指针，这个函数指针包含的是 OC 里面写在 Block 里面的代码。</li>
</ol>
<p><br></p>
<p><strong><code>__main_block_desc_0</code> 的内容:</strong></p>
<ol>
<li><code>size_t reserved;</code>  (保留变量</li>
<li><code>size_t Block_size;</code>  (保存 Block 的大小</li>
</ol>
<p><br></p>
<h2 id="Block-截获变量"><a href="#Block-截获变量" class="headerlink" title="Block 截获变量"></a>Block 截获变量</h2><p>上面一节大概了解了 Block 是个什么东西，这一节则会进行更深入的探索，搞清楚 Block 对各种类型的变量在内部是如何处理。下面通过 clang 转换一个包含各种变量的 Block 来分析这些问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/** 转换前的 Objective-C 代码(ARC): */</div><div class="line">typedef void(^blk_t)();</div><div class="line"></div><div class="line">static int static_global_val = 1;       // 静态全局变量(C</div><div class="line">static NSObject *static_global_obj;     // 静态全局变量(OC</div><div class="line">int global_val = 1;                     // 全局变量(C</div><div class="line">NSObject *global_obj;                   // 全局变量(OC</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    int automatic_val = 1;                                   // 自动变量(C</div><div class="line">    NSObject *automatic_obj = [NSObject new];      		    // 自动变量(OC</div><div class="line">    </div><div class="line">    __block int __block_val = 1;                             // __block变量(C</div><div class="line">    __block NSObject *__block_obj = [NSObject new]; 		// __block变量(OC</div><div class="line">    </div><div class="line">    static int static_val = 1;                               // 静态变量(C</div><div class="line">    static NSObject *static_obj;                             // 静态变量(OC</div><div class="line">    </div><div class="line">    static_global_obj = [NSObject new];</div><div class="line">    global_obj = [NSObject new];</div><div class="line">    static_obj = [NSObject new];</div><div class="line">    </div><div class="line">    blk_t block = ^&#123;</div><div class="line">      static_global_val = 1;</div><div class="line">      static_global_obj = [NSArray array];</div><div class="line">      global_val = 1;</div><div class="line">      global_obj = [NSArray array];  </div><div class="line">      static_val = 1;</div><div class="line">      static_obj = [NSArray array];</div><div class="line">        </div><div class="line">      __block_val = 1;</div><div class="line">      __block_obj = [NSArray array];</div><div class="line">      printf(&quot;%d,%p&quot;, automatic_val, automatic_obj);</div><div class="line">      //automatic_val = 1; 			    // 报错</div><div class="line">      //automatic_obj = [NSArray array]; // 报错</div><div class="line">    &#125;;</div><div class="line">    block();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<p>下面是转换成 C++ 的代码， 其中裁剪出重要的内容来显示，代码后面是分析上面问题的答案:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">/** 转换后的C++代码(ARC): */</div><div class="line">typedef void(*blk_t)();</div><div class="line"></div><div class="line">static int static_global_val = 1;</div><div class="line">static NSObject *static_global_obj;</div><div class="line">int global_val = 1;</div><div class="line">NSObject *global_obj;</div><div class="line"></div><div class="line">struct __Block_byref___block_val_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">  __Block_byref___block_val_0 *__forwarding;</div><div class="line">  int __flags;</div><div class="line">  int __size;</div><div class="line">  int __block_val;</div><div class="line">&#125;;</div><div class="line">struct __Block_byref___block_obj_1 &#123;</div><div class="line">  void *__isa;</div><div class="line">  __Block_byref___block_obj_1 *__forwarding;</div><div class="line">  int __flags;</div><div class="line">  int __size;</div><div class="line">  void (*__Block_byref_id_object_copy)(void*, void*);</div><div class="line">  void (*__Block_byref_id_object_dispose)(void*);</div><div class="line">  NSObject *__block_obj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int *static_val;</div><div class="line">  NSObject **static_obj;</div><div class="line">  int automatic_val;</div><div class="line">  NSObject *automatic_obj;</div><div class="line">  __Block_byref___block_val_0 *__block_val; // by ref</div><div class="line">  __Block_byref___block_obj_1 *__block_obj; // by ref</div><div class="line">  </div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, NSObject **_static_obj, int _automatic_val, NSObject *_automatic_obj, __Block_byref___block_val_0 *___block_val, __Block_byref___block_obj_1 *___block_obj, int flags=0) : static_val(_static_val), static_obj(_static_obj), automatic_val(_automatic_val), automatic_obj(_automatic_obj), __block_val(___block_val-&gt;__forwarding), __block_obj(___block_obj-&gt;__forwarding) &#123; </div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">    size_t reserved;</div><div class="line">    size_t Block_size;</div><div class="line">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123;0,sizeof(struct __main_block_impl_0),__main_block_copy_0,__main_block_dispose_0&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref___block_val_0 *__block_val = __cself-&gt;__block_val; // bound by ref</div><div class="line">  __Block_byref___block_obj_1 *__block_obj = __cself-&gt;__block_obj; // bound by ref</div><div class="line">  int *static_val = __cself-&gt;static_val;	   // bound by copy</div><div class="line">  NSObject **static_obj = __cself-&gt;static_obj; // bound by copy</div><div class="line"></div><div class="line">    static_global_val = 1;</div><div class="line">    static_global_obj = objc_msgSend(objc_getClass(&quot;NSArray&quot;), sel_registerName(&quot;array&quot;));</div><div class="line">    global_val = 1;</div><div class="line">    global_obj = objc_msgSend(objc_getClass(&quot;NSArray&quot;), sel_registerName(&quot;array&quot;));</div><div class="line"></div><div class="line">    (*static_val) = 1;</div><div class="line">    (*static_obj) = objc_msgSend(objc_getClass(&quot;NSArray&quot;), sel_registerName(&quot;array&quot;));</div><div class="line">    (__block_val-&gt;__forwarding-&gt;__block_val) = 1;</div><div class="line">    (__block_obj-&gt;__forwarding-&gt;__block_obj) = objc_msgSend(objc_getClass(&quot;NSArray&quot;), sel_registerName(&quot;new&quot;));</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src&#123;...&#125;</div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;...&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    int automatic_val = 1;</div><div class="line">    NSObject *automatic_obj = objc_msgSend((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;));</div><div class="line">  </div><div class="line">    __Block_byref___block_val_0 __block_val = &#123;(void*)0,&amp;__block_val,0,sizeof(__Block_byref___block_val_0),1&#125;;</div><div class="line">    __Block_byref___block_obj_1 __block_obj = &#123;(void*)0, &amp;__block_obj, 33554432, sizeof(__Block_byref___block_obj_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, objc_msgSend(objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;))&#125;;</div><div class="line"></div><div class="line">    static int static_val = 1;</div><div class="line">    static NSObject *static_obj;</div><div class="line"></div><div class="line">    static_global_obj = objc_msgSend(objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;));</div><div class="line">    global_obj = objc_msgSend(objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;));</div><div class="line">    static_obj = objc_msgSend(objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;));</div><div class="line">    </div><div class="line">    blk_t block = ((void (*)())&amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val, &amp;static_obj, automatic_val, automatic_obj, &amp;__block_val, &amp;__block_obj, 570425344));</div><div class="line">  </div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-Block-怎么处理自动变量"><a href="#1-Block-怎么处理自动变量" class="headerlink" title="1. Block 怎么处理自动变量?"></a>1. Block 怎么处理自动变量?</h4><p>从上面的  C++ 代码中可以看出，在 Block 对应的 <code>__main_block_impl_0</code> struct 中有和自动变量 <code>automatic_val</code> <code>automatic_obj</code>  相同的类型的结构体成员。 <code>__main_block_impl_0</code>  struct 的构造方法 <code>__main_block_impl_0</code> 的参数中也会接受 <code>automatic_val</code> <code>automatic_obj</code> 同类型的参数，然后把其赋值给对应的 strcut 成员。 可以看下在 <code>main</code> 函数中对 <code>__main_block_impl_0</code> 构造函数的调用。 这里有几个值得注意的点: </p>
<ol>
<li><p>对于 <code>C 基础类型</code>  <code>automatic_val</code> 直接传递的是值 <code>1</code> , 所以 mian 函数中定义的 <code>int automatic_val</code>  和 Block 对应结构体中的 <code>automatic_val</code>  结构体成员不是同一个变量。通过下面的小例子可以证明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">  int automatic_val = 1;</div><div class="line">  blk_t block = ^ &#123; printf(&quot;inside  in room val:%d \n&quot;,automatic_val);&#125;;</div><div class="line">  automatic_val = 2;</div><div class="line">  printf(&quot;outside in room val:%d \n&quot;,automatic_val);</div><div class="line">  </div><div class="line">  block();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是上面代码的输出，可以看到在 Block 外改变 val 的值根本影响不到 Block 内的值，因为他们不在同一块内存上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">outside in room val:2 </div><div class="line">inside  in room val:1</div></pre></td></tr></table></figure>
</li>
<li><p>对于 <code>OC 对象类型</code> <code>automatic_obj</code> 是直接传递指针，和 <code>automatic_val</code> 同理，如果在 Block  外新建一个 <code>OC 对象类型</code> 的指针，再赋值给 <code>automatic_obj</code> 变量也对 Block 内的 <code>automatic_obj</code> 结构体成员是没有影响的，因为这两个变量里面此时装的已经是不同的指针了。 但是当它们装的是同一个指针时，是可以通过调用对象的方法来相互影响的， 举个栗子，在 Block 外更改可变数组里的内容是会影响到 Block 内部的可变数组的，因为此时这两个变量是装的同一个指针:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    NSMutableArray *automatic_obj = [NSMutableArray arrayWithObjects:@&quot;1&quot;, @&quot;2&quot;, nil];</div><div class="line">    blk_t block = ^ &#123;</div><div class="line">        NSLog(@&quot;inside  in room obj: %@&quot;, automatic_obj);</div><div class="line">    &#125;;</div><div class="line">    [automatic_obj addObject:@&quot;3&quot;];</div><div class="line">    NSLog(@&quot;outside in room obj: %@&quot;, automatic_obj);</div><div class="line">  </div><div class="line">    block();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在  Block 对应的 <code>__main_block_impl_0</code> struct 中，修饰 <code>automatic_obj</code> 的是 strong 所有权修饰符，所以 Block 会对这个对象进行持有， 为什么系统这么去设计让 Block 持有自动变量? 是因为 Block 能够超出其所在的函数作用域存在，而 <code>OC 对象类型</code> 的自动变量在超出函数作用域时就会被释放被释放，Block 此时执行时这个对象已经被销毁了。为了避免这种情况 Block 持有了 <code>OC 对象类型</code> 的自动变量。</p>
</li>
</ol>
<p><br></p>
<h4 id="2-Block-怎么处理-静态全局变量-全局变量-静态变量"><a href="#2-Block-怎么处理-静态全局变量-全局变量-静态变量" class="headerlink" title="2. Block 怎么处理 静态全局变量 / 全局变量 / 静态变量 ?"></a>2. Block 怎么处理 静态全局变量 / 全局变量 / 静态变量 ?</h4><p>之所以把这三种变量归纳到一起，是因为它们的生命周期在一个程序中会一直存在。 Block 中使用 <code>静态全局变量</code> 和 <code>全局变量</code> 时，因为它们的作用域是全局的，并且是在程序中一直存在的，所以转换后这部分没有任何变化可以直接使用，并且可以在 Block 中重新赋值。 Block 中使用 <code>静态变量</code> 转换后会在 Block 对应的 <code>__main_block_impl_0</code> struct 中追加这个 <code>静态变量</code> 的类型的指针，然后通过 strcut 的构造函数传递进去，通过这种方式扩大了这个静态变量可访问的作用域， 使其可以在 <code>__main_block_func_0</code> 函数中访问。同时也因为传递的是 <code>静态变量</code> 类型的指针所以具备了重新赋值的能力。 </p>
<p><br></p>
<h4 id="3-Block-怎么处理-block-修饰的自动变量"><a href="#3-Block-怎么处理-block-修饰的自动变量" class="headerlink" title="3. Block 怎么处理 __block 修饰的自动变量 ?"></a>3. Block 怎么处理 __block 修饰的自动变量 ?</h4><p>上面的例子中 <code>__block</code> 修饰的自动变量 <code>__block_val</code> <code>__block_obj</code>  在转换后分别变成了 <code>__Block_byref___block_val_0</code>  和<code>__Block_byref___block_val_1</code>  结构体，并且它们第一个成员都是 <code>isa 指针</code>，这说明它们都是 OC 对象。第二个成员是 <code>__forwarding 指针</code> 目前是指向这个结构体的本身。 这两个结构体分别还包含着对应的 <code>__block</code> 自动变量类型的 结构体成员。</p>
<p><br></p>
<h2 id="Block-的储存域"><a href="#Block-的储存域" class="headerlink" title="Block 的储存域"></a>Block 的储存域</h2><p>因为 Block 对应的结构体第一个成员是 <code>isa 指针</code> ，所以 Block 也是个 <code>OC 对象</code> ，那么 <code>isa 指针</code> 指向的就是 Block 的类了。以前我们接触到的都是 <code>_NSConcreteStackBlock</code> ，其实还有另外两种: <code>_NSConcreteGlobalBlock</code> <code>_NSConcreteMallocBlock</code> 。 这一节就是来探讨这三种 Block 的不同和作用。</p>
<p><br></p>
<h4 id="三种-Block-在内存的存储区域"><a href="#三种-Block-在内存的存储区域" class="headerlink" title="三种 Block 在内存的存储区域"></a>三种 Block 在内存的存储区域</h4><ul>
<li><code>_NSConcreteStackBlock</code> 类的 Block 对象是设置栈区上的，超出其所在的函数作用域就会被释放。</li>
<li><code>_NSConcreteGlobalBlock</code> 类的 Block 对象是设置在 .data 区上，在程序运行时永久存在的。</li>
<li><code>_NSConcreteMallocBlock</code> 类的 Block 对象是设置在堆区上。</li>
</ul>
<h4 id="怎么区分这三种-Block"><a href="#怎么区分这三种-Block" class="headerlink" title="怎么区分这三种 Block"></a>怎么区分这三种 Block</h4><p><strong>_NSConcreteGlobalBlock</strong> </p>
<ul>
<li>在所有方法外定义的 Block 为 <code>Global Block</code></li>
<li>当 Block 中没有截获自动变量是为 <code>Global Block</code></li>
</ul>
<p><strong>_NSConcreteMallocBlock</strong> </p>
<p><code>Malloc Block</code> 是 <code>Stack Block</code> 被执行 copy 操作后得到的。它能让 Block 超出函数/方法的作用域而存在。</p>
<p><strong>_NSConcreteStackBlock</strong>  </p>
<p>除了上面的情况，剩下的就都是 <code>Stack Block</code> 了。当其所在的函数作用域结束时，这个 Block 就会被回收。</p>
<p><br></p>
<h4 id="那些情况系统会自动帮你调用-copy-方法"><a href="#那些情况系统会自动帮你调用-copy-方法" class="headerlink" title="那些情况系统会自动帮你调用 copy 方法"></a>那些情况系统会自动帮你调用 copy 方法</h4><p>通过 copy 操作可以让 <code>Stack Block</code> 拷贝成 <code>Malloc Block</code>，但是在一些情况下，系统会自动的帮我们执行 copy 操作:</p>
<ul>
<li><code>ARC</code> Block 作为函数返回值返回时会自动对 Block 执行 copy 操作。</li>
<li><code>ARC</code> 下将 Block 赋值给附有 <code>__strong</code>  修饰符的变量时。 所以在 <code>ARC</code> 下不用调用 copy 操作，直接把它赋值给 <code>__strong</code> 变量就可以达到效果，还有对于 Block 类型的 @property 的 attribute 不用写 copy。直接使用默认的 <code>__strong</code> ，有太多人在 <code>ARC</code> 下还是用 copy 去修饰。 完全没有必要</li>
<li>在方法名中含有 usingBlock 的 Cocoa 框架方法或 Grand Central Dispatch 的 API 中传递 Block 时。</li>
</ul>
<p><br></p>
<h4 id="Block-copy-时会发生什么-会造成什么影响"><a href="#Block-copy-时会发生什么-会造成什么影响" class="headerlink" title="Block copy 时会发生什么? 会造成什么影响?"></a>Block copy 时会发生什么? 会造成什么影响?</h4><p>大部分的 Block 对象是设置在栈内存上的，为了使 Block 能够超出其函数作用域的范围。可以使用 copy 操作将其从栈内存拷贝到堆内存中。对于 Block 中的 <code>__block</code> 变量一开始它也是配置在栈内存中的，在超出函数作用域时它也会被释放。所以在拷贝 Block 对象到堆内存中时，也会同时拷贝这个 Block 使用的 <code>__block</code> 变量到堆内存中。 当多个 Block 对象同时使用一个 <code>__block</code> 变量时，如果其中有个 Block 已经把 <code>__block</code> 变量拷贝到堆内存上了。后面的 Block 再次对这个 <code>__block</code> 变量执行 copy 操作时只会增加这个  <code>__block</code> 变量的持有。 等 Block 销毁时就会减少 <code>__block</code> 变量的持有。当没有 Block 持有 <code>__block</code> 变量时它就会被回收。这和我们一直使用的引用计数的内存管理方式相同。</p>
<p><br></p>
<h4 id="为什么要设计-forwarding-这个东西"><a href="#为什么要设计-forwarding-这个东西" class="headerlink" title="为什么要设计 __forwarding 这个东西?"></a>为什么要设计 __forwarding 这个东西?</h4><p>上一节的例子中 <code>__block_val</code> <code>__block_obj</code> 这两个 <code>__block</code> 变量在被转换后，分别变成了 <code>__Block_byref___block_val_0</code> <code>__Block_byref___block_val_1</code> 结构体，并且结构体的第二个成员都是 <code>__forwarding</code> 指针。 这个 <code>__forwarding</code> 指针目前是指向自己的。为什么要去设计 <code>__forwarding</code> 指针这个东西？这需要刚才讨论的 Block 对象的拷贝结合在一起看。</p>
<p><code>__forwarding</code> 指针存在的意义是不管 <code>__block</code> 变量是配置在栈上还是堆上，都能够正确的访问变量。当 Block 对象被拷贝到堆内存中是， <code>__block</code> 变量也被拷贝到堆内存中。那么此时可以同时访问栈上的 <code>__block</code> 变量 和 堆上的 <code>__block</code> 变量。他们都是通过下面的方式访问的， 都是通过 <code>__forarding</code> 指针: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__block_val-&gt;__forwarding-&gt;__block_val</div><div class="line">__block_obj-&gt;__forwarding-&gt;__block_obj</div></pre></td></tr></table></figure>
<p>栈上的 <code>__block</code> 在被拷贝到堆内存时，会改变栈内存的 <code>__forwarding</code> 指针，让其指向堆内存的 <code>__block</code> 变量。 所以通过这个设计让 访问的 <code>__block</code> 变量无论在 Block 中还是 Block外，<code>__block</code>变量是在堆内存还是栈内存上，访问的都是同一个 <code>__block</code> 变量。</p>
<p><br></p>
<h4 id="为什么-Block-中的静态变量可以修改，-而自动变量不能修改"><a href="#为什么-Block-中的静态变量可以修改，-而自动变量不能修改" class="headerlink" title="为什么 Block 中的静态变量可以修改， 而自动变量不能修改?"></a>为什么 Block 中的静态变量可以修改， 而自动变量不能修改?</h4><p>上面讲到 Block 对应的结构体因为保存的是 <code>静态变量</code> 的类型的指针，所以 <code>静态变量</code> 可以在 Block 中被重新赋值。那自动变量为什么不也设计成这样，使其拥有在 Block 中被重新赋值的能力呢?  这是因为自动变量的超出其所在的函数作用域时就会被销毁掉。但是 Block 又可以超出其自身作用域而存在。如果像对待 <code>静态变量</code> 那样去对待 <code>自动变量</code> ，很可能出现的情况就是当 Block 去操作/访问 <code>自动变量</code> 时。自动变量已经被销毁。</p>
<p><br></p>
<h2 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h2><p>这个关于 Block 的<a href="http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/" target="_blank" rel="external">小测试</a> 这是在唐巧的 blog 《<a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a>》 中发现的， 觉得很能考察对 Block 的理解程度，做到全对感觉对 Block 了解就很清楚了。</p>
<p><br></p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="external">Objective-C 高级编程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Block-的本质&quot;&gt;&lt;a href=&quot;#Block-的本质&quot; class=&quot;headerlink&quot; title=&quot;Block 的本质&quot;&gt;&lt;/a&gt;Block 的本质&lt;/h2&gt;&lt;p&gt;在 &lt;strong&gt;&lt;a href=&quot;http://tao.bio/2017/03/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objective-C Block Part1 - 介绍&amp;使用</title>
    <link href="http://yoursite.com/2017/03/26/Objective-C%20Block%20Part1%20-%20%E4%BB%8B%E7%BB%8D&amp;%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/03/26/Objective-C Block Part1 - 介绍&amp;使用/</id>
    <published>2017-03-26T08:11:12.000Z</published>
    <updated>2017-03-30T03:20:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Block-？"><a href="#什么是-Block-？" class="headerlink" title="什么是 Block ？"></a>什么是 Block ？</h2><p>Block 是苹果在 <code>iOS4</code> 添加的特性。它是一个带自动变量(局部变量)的匿名函数，同时也是 <code>OC 对象类型</code>，所以可以把 Block 赋值给一个变量，也可以存储在 <code>NSArray</code> <code>NSDictionary</code> 这样的容器中，或者作为函数返回值。Block 等同于其他语言中的 <code>closure</code> <code>lambda</code>。 Block 使用简单方便，在很多场景下可以替代 delegate。Block 在系统提供的 API 中也是随处可见。</p>
<h2 id="Block-的语法"><a href="#Block-的语法" class="headerlink" title="Block 的语法"></a>Block 的语法</h2><p>下面是一个完整的 Block 定义规则，Block 标志性的标识是 <code>^</code>  (caret 脱字符号)，这是每个 Block 必须拥有的。剩下的和匿名函数相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">^ 返回值类型 (参数列表) &#123;表达式&#125;;</div><div class="line">^ int(int v1, int v2) &#123;return v1 + v2;&#125;;</div></pre></td></tr></table></figure>
<p>如果返回值类型为 <code>void</code> ， 没有参数，这些都是可以省略，下面最简模式的 Block:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">^&#123;表达式&#125;;</div><div class="line">^&#123;printf(&quot;hello world!&quot;);&#125;;</div></pre></td></tr></table></figure>
<p>Block 也是 <code>OC 对象类型</code> 可以把 Block 赋值给变量或类属性。也可以通过 <code>typedef</code> 去简化定义 Block 类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef void(^blk_t)(); // 用 typedef 定义 Block 类型</div><div class="line"></div><div class="line">void(^block1)() = ^&#123;printf(&quot;简化前&quot;);&#125;;</div><div class="line">blk_t block2 = ^&#123;printf(&quot;简化后&quot;);&#125;;</div></pre></td></tr></table></figure>
<h2 id="Block-的使用规则"><a href="#Block-的使用规则" class="headerlink" title="Block 的使用规则"></a>Block 的使用规则</h2><h4 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h4><p>Block 一个很大的优点就是可以捕获外部变量在 Block 内使用，并且除了特定情况，只要 Block 存在这个被捕获的变量就能够一直使用。 这个规则对 <code>局部变量</code> <code>静态变量</code> <code>全局变量</code> <code>静态全局变量</code> 都有效。但是其中的 <code>局部变量</code> 不能够在 Block 中被重新赋值。可以对 <code>局部变量</code> 加上 <code>__block</code> 说明符去解决这个问题。 下面举一个栗子来佐证刚才的说法，以下代码基于 <code>ARC</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">typedef void(^blk_t)();</div><div class="line"></div><div class="line">static int static_global_val = 1;                       // 静态全局变量(C  基础类型</div><div class="line">static id static_global_obj;                            // 静态全局变量(OC 对象类型</div><div class="line">int global_val = 1;                                     // 全局变量(C  基础类型</div><div class="line">id  global_obj;                                         // 全局变量(OC 对象类型</div><div class="line"></div><div class="line">@interface TObject : NSObject</div><div class="line">@property (nonatomic) blk_t block;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TObject</div><div class="line">- (instancetype)init &#123;</div><div class="line">    self = [super init];</div><div class="line">  </div><div class="line">    int automatic_val = 1;                             // 自动变量(C  基础类型</div><div class="line">    id  automatic_obj = [[NSObject alloc] init];       // 自动变量(OC 对象类型</div><div class="line">    static int static_val = 1;                         // 静态变量(C  基础类型</div><div class="line">    static id  static_obj;                             // 静态变量(OC 对象类型</div><div class="line">    </div><div class="line">    static_global_obj = [NSObject new];</div><div class="line">    global_obj = [NSObject new];</div><div class="line">    static_obj = [NSObject new];</div><div class="line">    </div><div class="line">    self.block = ^&#123;</div><div class="line">        NSLog(@&quot;static_global_val: %d&quot;, static_global_val);</div><div class="line">        NSLog(@&quot;static_global_obj: %@&quot;, static_global_obj);</div><div class="line">        NSLog(@&quot;global_val: %d&quot;, global_val);</div><div class="line">        NSLog(@&quot;global_obj: %@&quot;, global_obj);</div><div class="line">        NSLog(@&quot;static_val: %d&quot;, static_val);</div><div class="line">        NSLog(@&quot;static_obj: %@&quot;, static_obj);</div><div class="line">        NSLog(@&quot;automatic_val: %d&quot;, automatic_val);</div><div class="line">        NSLog(@&quot;automatic_obj: %@&quot;, automatic_obj);</div><div class="line">        </div><div class="line">        static_global_val = 0;</div><div class="line">        static_global_obj = [NSArray array];</div><div class="line">        global_val = 0;</div><div class="line">        global_obj = [NSArray array];</div><div class="line">        static_val = 0;</div><div class="line">        static_obj = [NSArray array];</div><div class="line">      </div><div class="line">//        automatic_val = 0;</div><div class="line">//        automatic_obj = [NSArray array];</div><div class="line">    &#125;;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">  </div><div class="line">    TObject *obj = [[TObject alloc] init];</div><div class="line">    obj.block();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子定义了各种各样的变量并在 block 中使用它们，通过观察他们的表现来佐证我们的观点。在 Block 中注释的两行代码试图去更改 <code>C 对象类型</code> 和 <code>OC 对象类型</code> 的自动变量，但是并没有成功。这里编译器均会报错:  <code>Variable is not assignable (missing __block type specifier)</code> ，编译器告诉我们这两个变量不能被赋值，可以通过加上 <code>__block</code> 说明符去解决这个问题。这刚好验证了上面的说法。 下面的代码块里的内容是上面代码执行后的输出。虽然在 main 函数中执行 block 时，自动变量 <code>automatic_val</code> <code>automatic_obj</code> 已经超出了其所在的函数作用域，但是仍然能打印出里面的值。这点也是符合预期的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">2017-03-26 20:15:34.264803 BlockDemo[75799:23910278] static_global_val: 1</div><div class="line">2017-03-26 20:15:34.265551 BlockDemo[75799:23910278] static_global_obj: &lt;NSObject: 0x100202e00&gt;</div><div class="line">2017-03-26 20:15:34.265579 BlockDemo[75799:23910278] global_val: 1</div><div class="line">2017-03-26 20:15:34.265724 BlockDemo[75799:23910278] global_obj: &lt;NSObject: 0x1002000c0&gt;</div><div class="line">2017-03-26 20:15:34.265773 BlockDemo[75799:23910278] static_val: 1</div><div class="line">2017-03-26 20:15:34.265825 BlockDemo[75799:23910278] static_obj: &lt;NSObject: 0x100203b00&gt;</div><div class="line">2017-03-26 20:15:34.265860 BlockDemo[75799:23910278] automatic_val: 1</div><div class="line">2017-03-26 20:15:34.265927 BlockDemo[75799:23910278] automatic_obj: &lt;NSObject: 0x1002024b0&gt;</div></pre></td></tr></table></figure>
<h4 id="正确的储存-Block"><a href="#正确的储存-Block" class="headerlink" title="正确的储存 Block"></a>正确的储存 Block</h4><p>文章的开头我们就讲到了 Block 是一个 OC 对象， 可以把它赋值给一个变量存储起来。但是这里 Block 和普通OC对象还是有一点细小的区别的，操作不当有可能 Block 就会被提前释放掉。</p>
<p><code>MRC</code> 下要储存定义在函数内并且截获了自动变量的 Block 时。 如果期望它能超出函数作用域之外，需要先对 Block 进行 <code>copy</code> 操作，然后把返回的结果赋值给变量。或者赋值给 <code>Property</code> 时需要把它的 <code>attribute</code> 设置为 <code>copy</code> ，例如: <code>@property (copy) blk_t block;</code> 。 此时就和管理普通对象的内存无异了。可以对其 <code>retain</code> <code>release</code> 。</p>
<p><code>ARC</code> 下则完全和普通对象一样，使用 <code>__strong</code> 的修饰符的变量就好。不需要像 <code>MRC</code> 下去做 <code>copy</code> 操作</p>
<h4 id="避免循环引用"><a href="#避免循环引用" class="headerlink" title="避免循环引用"></a>避免循环引用</h4><p>上面已经展示过 Block 可以捕获自动变量，并且可以让其超过它自身所在的函数作用域而存在。Block 能有这个功能只是因为它持有了这个变量，这个变量只要 Block 存在它就会存在。但是这样会有一个安全隐患—会产生循环引用。例如下面的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/// 运行在 ARC 下:</div><div class="line">typedef void(^blk_t)();</div><div class="line"></div><div class="line">@interface TObject : NSObject</div><div class="line">@property (nonatomic, copy) blk_t block;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TObject</div><div class="line">- (instancetype)init &#123;</div><div class="line">    self = [super init];</div><div class="line">    self.block = ^&#123; NSLog(@&quot;%@&quot;, self); &#125;;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面你的代码，self 持有 block，但 block 也持有了 self。所以就循环引用了，谁也释放不了谁，造成内存泄漏。解决办法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    __block __typeof(self) weakSelf = self;	// MRC 的情况下</div><div class="line">    __weak __typeof(self) weakSelf = self;  // ARC 的情况下</div><div class="line">    self.block = ^&#123; NSLog(@&quot;%@&quot;, weakSelf);&#125;;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>MRC</code> 下使用 <code>__block</code> 说明符去避免循环引用</p>
<p>在 <code>ARC</code> 下使用 <code>__weak</code> 修饰符去避免循环应用</p>
<p>这两种方法都能在对应的内存管理机制下，让 Block 不 <code>retain</code> 或 强持有 截获的 self。 因为 self 持有 block。 所以也不用担心 block 执行时 self 会被释放。这就解决 Block 循环引用的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Block-？&quot;&gt;&lt;a href=&quot;#什么是-Block-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Block ？&quot;&gt;&lt;/a&gt;什么是 Block ？&lt;/h2&gt;&lt;p&gt;Block 是苹果在 &lt;code&gt;iOS4&lt;/code&gt; 添加的特性
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS Grand Central Dispatch 的使用</title>
    <link href="http://yoursite.com/2017/02/21/iOS%20Grand%20Central%20Dispatch%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/02/21/iOS Grand Central Dispatch 的使用/</id>
    <published>2017-02-21T12:15:26.000Z</published>
    <updated>2017-03-31T03:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-GCD"><a href="#什么是-GCD" class="headerlink" title="什么是 GCD ?"></a>什么是 GCD ?</h1><p><code>GCD</code> 全称为 <code>Grand Central Dispatch</code> ， 是一个异步执行任务的技术。 它将应用程序中线程管理用的代码在系统级中实现。 开发者只需要定义想执行的任务并追加到适当的 <code>Dispatch Queue</code> 中， <code>GCD</code> 就能生成必要的线程并执行任务。 由于线程管理是作为系统的一部分来实现的， 因此可统一管理，也可执行任务，这样就比以前的线程更有效率。</p>
<p>相对于直接去写多线程的代码。通过 <code>GCD</code> 去使用多线程技术不仅非常简单，并且避免一些多线程操作中可能出现的问题。开发者要做的只是定义想执行的任务并追加到适当的 <code>Dispatch Queue</code> 中。</p>
<h1 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h1><h4 id="Dispatch-Queue-介绍"><a href="#Dispatch-Queue-介绍" class="headerlink" title="Dispatch Queue 介绍"></a>Dispatch Queue 介绍</h4><p><code>Dispatch Queue</code> 是执行等待任务的队列。在使用 <code>GCD</code> 执行任务时，添加任务到对应的 <code>Dispatch Queue</code> 中。由 <code>Dispatch Queue</code> 控制怎么在线程上执行任务。<code>Dispatch_Queue</code> 按照任务追加的顺序执行(FIFO)。  <code>Dispatch Queue</code> 分类两种类型: </p>
<ul>
<li><strong>Serial Dispatch Queue:</strong> 是一个串行队列，添加到这个队列中的任务会按照顺序一个任务执行完后才会执行下一个任务。</li>
</ul>
<ul>
<li><strong>Concurrent Dispatch Queue:</strong> 是一个并行队列，添加到这个队列中的任务会多个任务同时执行。但是具体同时能执行多少个任务，这个<code>XNU 内核</code> 去帮我们管理的。</li>
</ul>
<h4 id="创建-Dispatch-Queue"><a href="#创建-Dispatch-Queue" class="headerlink" title="创建 Dispatch Queue"></a>创建 Dispatch Queue</h4><p>获取上面两种 <code>Dispatch Queue</code> 可以通过 <code>dispatch_queue_create</code> 函数去创建。这个函数返回代表 <code>Dispatch Queue</code> 的 <code>dispatch_queue_t</code> 类型变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t dispatch_queue_create(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr);</div><div class="line">// 其中第一个参数传入一个 C 字符串，作为名字来标识一个 Dispatch Queue ，这个名字在调试中非常有用，会显示在调试面板上。</div><div class="line">// 第二个参数如果创建 Serial Dispatch Queue 则填入 NULL 。 </div><div class="line">// 如果需要创建 Concurrent Dispatch Queue 则填入DISPATCH_QUEUE_CONCURRENT。</div></pre></td></tr></table></figure>
<h4 id="获取系统提供的-Dispatch-Queue"><a href="#获取系统提供的-Dispatch-Queue" class="headerlink" title="获取系统提供的 Dispatch Queue"></a>获取系统提供的 Dispatch Queue</h4><p>如果不自己创建 <code>Dispatch Queue</code> ，系统也开发者提供了<code>Main Dispatch Queue</code> <code>Global Dispatch Queue</code> 。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mainQueue             = dispatch_get_main_queue();</div><div class="line">dispatch_queue_t globalQueueHigh       = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</div><div class="line">dispatch_queue_t globalQueueDefault    = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_queue_t globalQueueLow        = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</div><div class="line">dispatch_queue_t globalQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</div><div class="line"></div><div class="line">// dispatch_get_main_queue 方法获得的是 Serial Dispatch Queue，主线程就是在这个 Dispatch Queue 内。</div><div class="line">// dispatch_get_global_queue 方法获得都是 Concurrent Dispatch Queue。其第一个参数表示优先级，第二是保留字段(填0);</div></pre></td></tr></table></figure>
<h1 id="dispatch-async-amp-dispatch-sync"><a href="#dispatch-async-amp-dispatch-sync" class="headerlink" title="dispatch_async &amp; dispatch_sync"></a>dispatch_async &amp; dispatch_sync</h1><h4 id="dispatch-async-amp-dispatch-sync-介绍"><a href="#dispatch-async-amp-dispatch-sync-介绍" class="headerlink" title="dispatch_async &amp; dispatch_sync 介绍"></a>dispatch_async &amp; dispatch_sync 介绍</h4><p> <code>dispatch_async</code> 和 <code>dispatch_sync</code> 这两个函数都可以把 <code>Block任务</code> 绑定到指定的 <code>Dispatch Queue</code> 中执行。区别从方法名中就可以看出。<code>dispatch_async</code> 是异步执行，<code>dispatch_sync</code> 是同步执行。看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;1...&quot;);</div><div class="line">dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">    sleep(1); NSLog(@&quot;dispatch_sync&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;2...&quot;);</div><div class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">    sleep(1); NSLog(@&quot;dispatch_async&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;3...&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 上面这段代码执行的输出是:</div><div class="line">2017-02-22 21:47:18.545 OCGCD[47679:28023198] 1...</div><div class="line">2017-02-22 21:47:19.605 OCGCD[47679:28023198] dispatch_sync</div><div class="line">2017-02-22 21:47:19.606 OCGCD[47679:28023198] 2...</div><div class="line">2017-02-22 21:47:19.606 OCGCD[47679:28023198] 3...</div><div class="line">2017-02-22 21:47:20.675 OCGCD[47679:28023256] dispatch_async</div></pre></td></tr></table></figure>
<p>可以看出 <code>dispatch_sync</code> 这个函数会等到其 Block 内的任务执行完毕才会返回，然后继续往下执行。<code>dispatch_async</code> 则是直接返回继续往下执行，其 Block 内的任务会异步的去执行。</p>
<h4 id="dispatch-async-amp-dispatch-sync-和线程"><a href="#dispatch-async-amp-dispatch-sync-和线程" class="headerlink" title="dispatch_async &amp; dispatch_sync 和线程"></a>dispatch_async &amp; dispatch_sync 和线程</h4><p>上面说过 <code>GCD</code> 的背后是系统内核在管理线程，那 <code>dispatch_async</code> 和 <code>dispatch_sync</code> 执行相关了队列和线程那些关联呢? 看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serial     = dispatch_queue_create(&quot;io.tao.serial&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_queue_t concurrent = dispatch_queue_create(&quot;io.tao.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_queue_t mainQueue  = dispatch_get_main_queue();</div><div class="line"></div><div class="line">dispatch_sync (serial,     ^&#123; NSLog(@&quot;1: %@&quot;, [NSThread currentThread]); &#125;);</div><div class="line">dispatch_async(serial,     ^&#123; NSLog(@&quot;2: %@&quot;, [NSThread currentThread]); &#125;);</div><div class="line">dispatch_sync (concurrent, ^&#123; NSLog(@&quot;3: %@&quot;, [NSThread currentThread]); &#125;);</div><div class="line">dispatch_async(concurrent, ^&#123; NSLog(@&quot;4: %@&quot;, [NSThread currentThread]); &#125;);</div><div class="line">dispatch_async(mainQueue,  ^&#123; NSLog(@&quot;5: %@&quot;, [NSThread currentThread]); &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 上面这段代码执行的输出是:</div><div class="line">2017-02-22 22:29:04.783 OCGCD[50871:28074784] 1: &lt;NSThread: 0x6080000646c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">2017-02-22 22:29:04.783 OCGCD[50871:28074818] 2: &lt;NSThread: 0x60000006ba40&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">2017-02-22 22:29:04.783 OCGCD[50871:28074784] 3: &lt;NSThread: 0x6080000646c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">2017-02-22 22:29:04.784 OCGCD[50871:28074819] 4: &lt;NSThread: 0x60000006b800&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2017-02-22 22:29:04.789 OCGCD[50871:28074784] 5: &lt;NSThread: 0x6080000646c0&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>由上面的例子得出，无论是 <code>Serial Dispatch Queue</code> 还是 <code>Concurrent Dispatch Queue</code></p>
<p>通过 <code>dispatch_sync</code> 函数执行的都会在当前线程中执行任务。</p>
<p>通过 <code>dispatch_async</code> 函数执行的都会在子线程中执行任务。</p>
<p>但是有一个例外是 使用 <code>dispatch_async</code> 执行 <code>mainQueue</code> 队列也是在当前线程中执行的。永远都只会在主线程中执行。</p>
<h4 id="dispatch-sync-和-死锁"><a href="#dispatch-sync-和-死锁" class="headerlink" title="dispatch_sync 和 死锁"></a>dispatch_sync 和 死锁</h4><p>细心的人可能已经发现，上面的例子没有出现下面这行代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(mainQueue,  ^&#123; NSLog(@&quot;6: %@&quot;, [NSThread currentThread]); &#125;);</div></pre></td></tr></table></figure>
<p>因为这行代码在主线程中执行时会产生死锁，程序会 <strong>Carsh</strong> 。产生死锁的原因是: 因为该代码在 <code>Main Dispatch Queue(主线程)</code> 中使用 <code>dispatch_sync</code> 在 <code>Main Dispatch Queue(主线程)</code> 上执行 <code>Block 任务</code> ， <code>Main Dispatch Queue(主线程)</code> 在一直等着 <code>dispatch_sync</code> 函数返回再继续执行，但是 <code>dispatch_sync</code> 又需要在 <code>Main Dispatch Queue(主线程)</code> 执行<code>Block 任务</code>，所以这就像是一个死胡同，永远也等不到 <code>dispatch_sync</code>  函数返回。下面这个例子也是同样的问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serial = dispatch_queue_create(&quot;io.tao.q1&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_async(serial, ^&#123;</div><div class="line">    dispatch_sync(serial, ^&#123; NSLog(@&quot;Are you ok?&quot;); &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>所以在使用 <code>dispatch_sync</code> 函数去执行 <code>Serial Dispatch Queue</code> 队列时，要特别小心死锁的问题。在当前 <code>Dispatch Queue</code> 上去让 <code>dispatch_queue</code> 在当前 <code>Dispatch Queue</code> 执行任务时就会产生死锁。</p>
<h1 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h1><h4 id="dispatch-after-介绍"><a href="#dispatch-after-介绍" class="headerlink" title="dispatch_after 介绍"></a>dispatch_after 介绍</h4><p> <code>dispatch_after</code> 可以让 <code>Block 任务</code> 在指定时间后加入到 <code>Dispatch Queue</code> 中执行，并非在指定时间后执行 <code>Block 任务</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);</div><div class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;dispatch_after&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 上面的例子等同于 3 秒之后调用下面的代码</div><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">	NSLog(@&quot;dispatch_after&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="dispatch-time-介绍"><a href="#dispatch-time-介绍" class="headerlink" title="dispatch_time 介绍"></a>dispatch_time 介绍</h4><p>上面的例子中 <code>dispatch_after</code> 第一个参数是指定时间 <code>dispatch_time_t</code> 类型的值。<code>dispatch_time_t</code> 函数定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta);</div><div class="line">// 第一个参数指定时间的开始, 一般使用 DISPATCH_NOTHROW 表示现在的时间。</div><div class="line">// 第二个参数表示延后的时间，默认单位是纳秒, 可以 * NSEC_PER_SEC NSEC_PER_MSEC NSEC_PER_USEC 相关时间单位倍数来转换</div></pre></td></tr></table></figure>
<h1 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h1><h4 id="dispatch-apply-介绍"><a href="#dispatch-apply-介绍" class="headerlink" title="dispatch_apply 介绍"></a>dispatch_apply 介绍</h4><p><code>dispatch_apply</code> 可以多次执行一个队列里的 Block 任务，它会为 Block 任务提供一个计次的参数。  它和 <code>dispatch_sync</code> 一样，需要等到所有 Block 任务执行完，这个函数才会返回。 所以也要主要死锁的问题，当队列是 <code>Serial Dispatch Queue</code> 时，不要在当前 <code>Dispatch Queue</code> 上去让 <code>dispatch_apply</code> 在当前 <code>Dispatch Queue</code> 执行任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_apply(3, dispatch_get_global_queue(0, 0), ^(size_t index) &#123;</div><div class="line">    NSLog(@&quot;%zu&quot;, index);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;done&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 上面的例子的输出，done 总是在最后输出。刚好可以验证上面的说法。dispatch_applay 是同步去执行的</div><div class="line">2017-02-23 13:23:27.041 OCGCD[14310:28921393] 1</div><div class="line">2017-02-23 13:23:27.042 OCGCD[14310:28921396] 2</div><div class="line">2017-02-23 13:23:27.042 OCGCD[14310:28921344] 0</div><div class="line">2017-02-23 13:23:27.043 OCGCD[14310:28921344] done</div></pre></td></tr></table></figure>
<h1 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h1><h4 id="用其设置队列的优先级"><a href="#用其设置队列的优先级" class="headerlink" title="用其设置队列的优先级"></a>用其设置队列的优先级</h4><p>上面有例子通过 <code>dispatch_get_global_queue</code> 去生成不同优先级的队列。通过 <code>dispatch_queue_create</code> 函数生成的 <strong>Dispatch Queue</strong> 的优先级都是默认的，如果要改变它们优先级可以通过 <code>dispatch_set_target_queue</code> ，看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</div><div class="line">dispatch_queue_t queue 	   = dispatch_queue_create(&quot;io.tao.serial&quot;, NULL);</div><div class="line">dispatch_set_target_queue(queue, queueHigh);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 上面的例子，把默认优先级的 queue， 设置成和 queueHigh 一样的高优先级</div><div class="line">// 第一个参数填入要设置的 Dispatch Queue</div><div class="line">// 第二个参数填入要参照的目标 Dispatch Queue</div></pre></td></tr></table></figure>
<h4 id="设置多个-Serial-Dispatch-Queue-的执行顺序"><a href="#设置多个-Serial-Dispatch-Queue-的执行顺序" class="headerlink" title="设置多个 Serial Dispatch Queue 的执行顺序"></a>设置多个 Serial Dispatch Queue 的执行顺序</h4><p>多个 <code>Serial Dispatch Queue</code> 是并行执行的。但是开发碰到了要让它们串行执行的需求时，也可以通过 <code>dispatch_set_target_queue</code> 方法来实现。只需要把多个 <code>Serial Dispatch Queue</code> 设置成同一个目标  <code>Serial Dispatch Queue</code>  就可以了。看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue  = dispatch_queue_create(&quot;io.tao.serial&quot;, NULL);</div><div class="line">dispatch_queue_t serialQueue1 = dispatch_queue_create(&quot;io.tao.app.serial1&quot;, NULL);</div><div class="line">dispatch_queue_t serialQueue2 = dispatch_queue_create(&quot;io.tao.app.serial2&quot;, NULL);</div><div class="line">dispatch_queue_t serialQueue3 = dispatch_queue_create(&quot;io.tao.app.serial3&quot;, NULL);</div><div class="line"></div><div class="line">dispatch_set_target_queue(serialQueue1, serialQueue);</div><div class="line">dispatch_set_target_queue(serialQueue2, serialQueue);</div><div class="line">dispatch_set_target_queue(serialQueue3, serialQueue);</div><div class="line"></div><div class="line">NSLog(@&quot;start...&quot;);</div><div class="line">dispatch_async(serialQueue1, ^&#123;</div><div class="line">    sleep(1);</div><div class="line">    NSLog(@&quot;serialQueue1&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(serialQueue2, ^&#123;</div><div class="line">    NSLog(@&quot;serialQueue2&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(serialQueue3, ^&#123;</div><div class="line">    NSLog(@&quot;serialQueue3&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;end...&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 下面是上面例子的控制台输出。</div><div class="line">// serialQueue1, serialQueue2, serialQueue3 成功的按照顺序输出了。 </div><div class="line">2017-02-23 14:15:21.033 OCGCD[18304:28985032] start...</div><div class="line">2017-02-23 14:15:21.033 OCGCD[18304:28985032] end...</div><div class="line">2017-02-23 14:15:22.105 OCGCD[18304:28985092] serialQueue1</div><div class="line">2017-02-23 14:15:22.105 OCGCD[18304:28985092] serialQueue2</div><div class="line">2017-02-23 14:15:22.105 OCGCD[18304:28985092] serialQueue3</div></pre></td></tr></table></figure>
<h1 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h1><h4 id="dispatch-group-介绍"><a href="#dispatch-group-介绍" class="headerlink" title="dispatch_group 介绍"></a>dispatch_group 介绍</h4><p><code>dispatch_group</code> 允许把多个 <strong>Dispatch Queue</strong> 添加到一个 Group 中，等 Group 中所有的 <strong>Dispatch Queue</strong> 执行完成后，Group 会执行添加的特定 <code>Block 任务</code>。无论是 <strong>Serial Dispatch Queue</strong> 还是 <strong>Concurrent Dispatch Queue</strong> 都是有效的。 这在实际开发中非常有用。看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serial     = dispatch_queue_create(&quot;io.tao.serial&quot;, NULL);</div><div class="line">dispatch_queue_t concurrent = dispatch_queue_create(&quot;io.tao.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_group_t group      = dispatch_group_create();</div><div class="line"></div><div class="line">dispatch_group_async(group, serial,     ^&#123; sleep(3); NSLog(@&quot;serial1&quot;);&#125;);</div><div class="line">dispatch_group_async(group, serial,     ^&#123; sleep(2); NSLog(@&quot;serial2&quot;);&#125;);</div><div class="line">dispatch_group_async(group, concurrent, ^&#123; sleep(1); NSLog(@&quot;concurrent1&quot;);&#125;);</div><div class="line">dispatch_group_async(group, concurrent, ^&#123; sleep(2); NSLog(@&quot;concurrent2&quot;);&#125;);</div><div class="line"></div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;Group 中所有的 Dispatch Queue 已执行完&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 下面是上面例子的控制台输出。</div><div class="line">2017-02-23 14:30:06.566 OCGCD[19452:29004031] concurrent1</div><div class="line">2017-02-23 14:30:07.494 OCGCD[19452:29004033] concurrent2</div><div class="line">2017-02-23 14:30:08.494 OCGCD[19452:29004030] serial1</div><div class="line">2017-02-23 14:30:10.561 OCGCD[19452:29004030] serial2</div><div class="line">2017-02-23 14:30:10.561 OCGCD[19452:29003990] Group 中所有的 Dispatch Queue 已执行完</div></pre></td></tr></table></figure>
<p>在添加到 <strong>Dispatch Group</strong> 中的所有任务全部执行结束后， 就会把 <code>dispatch_group_notify</code> 中的 <code>Block 任务</code> 添加对指定队列中执行。来做一些结束工作。</p>
<h4 id="dispatch-group-wait-的使用"><a href="#dispatch-group-wait-的使用" class="headerlink" title="dispatch_group_wait 的使用"></a>dispatch_group_wait 的使用</h4><p>除了通过 <code>dispatch_group_notify</code> 获得 <strong>Dispatch Group</strong> 执行完的通知，也能通过 <code>dispatch_group_wait</code> 函数来获取结束通知。这个函数会一直等着 <strong>Dispatch Group</strong> 执行完成才会返回。 它就像是一个断点，把当前线程给断住，直到 Group 的所有任务执行完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t concurrent = dispatch_queue_create(&quot;io.tao.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_group_t group      = dispatch_group_create();</div><div class="line"></div><div class="line">dispatch_group_async(group, concurrent, ^&#123; sleep(3); NSLog(@&quot;concurrent1&quot;);&#125;);</div><div class="line">dispatch_group_async(group, concurrent, ^&#123; sleep(2); NSLog(@&quot;concurrent2&quot;);&#125;);</div><div class="line"></div><div class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line">NSLog(@&quot;Dispatch Group 中所有任务都已执行完毕&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 上面例子的控制台输出。刚好能证明上面的观点</div><div class="line">2017-02-23 14:44:16.883 OCGCD[20511:29021074] concurrent2</div><div class="line">2017-02-23 14:44:17.881 OCGCD[20511:29021077] concurrent1</div><div class="line">2017-02-23 14:44:17.882 OCGCD[20511:29021036] Dispatch Group 中所有任务都已执行完毕</div></pre></td></tr></table></figure>
<h1 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h1><h4 id="dispatch-barrier-async-介绍"><a href="#dispatch-barrier-async-介绍" class="headerlink" title="dispatch_barrier_async 介绍"></a>dispatch_barrier_async 介绍</h4><p><strong>Barrier</strong> 如同它的名字一样，它就像一个屏障把 <strong>Concurrent Dispatch Queue</strong> 里的多个任务给隔离开了。 <strong>Concurrent Dispatch Queue</strong>里的 <code>Block 任务</code> 是并行执行的，有时候想控制它们执行一部分 <code>Block 任务</code> 后，再执行特定操作，最后执行剩下的其他的 <code>Block 任务</code>。    <code>dispatch_barrier_async</code> 就可以帮我们做到。看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t concurrent = dispatch_queue_create(&quot;io.tao.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 1&quot;);&#125;);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 2&quot;);&#125;);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 3&quot;);&#125;);</div><div class="line">dispatch_barrier_sync(concurrent, ^&#123; sleep(3); NSLog(@&quot;barrier&quot;);&#125;);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 4&quot;);&#125;);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 5&quot;);&#125;);</div><div class="line">dispatch_async(concurrent, ^&#123;NSLog(@&quot;concurrent 6&quot;);&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 上面例子的控制台输出。注意每条 Log 的时间，concurrent 3 到 barrier 间隔了3秒</div><div class="line">2017-02-23 15:17:04.968 OCGCD[22872:29058218] concurrent 1</div><div class="line">2017-02-23 15:17:04.968 OCGCD[22872:29058220] concurrent 2</div><div class="line">2017-02-23 15:17:04.969 OCGCD[22872:29058217] concurrent 3</div><div class="line">2017-02-23 15:17:08.039 OCGCD[22872:29058165] barrier</div><div class="line">2017-02-23 15:17:08.040 OCGCD[22872:29058217] concurrent 4</div><div class="line">2017-02-23 15:17:08.040 OCGCD[22872:29058220] concurrent 5</div><div class="line">2017-02-23 15:17:08.040 OCGCD[22872:29058218] concurrent 6</div></pre></td></tr></table></figure>
<h1 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h1><p><strong>Dispatch Semaphore</strong> 是基于计数的信号，在 <code>GCD</code> 中控制并发队列同步的方法之一。 多个队列同时访问修改一个数据时，可能会产生数据不一致的情况，又是程序还会 <strong>Carsh</strong>。这是就可以通过 <strong>Dispatch Semaphore</strong> 去解决。 </p>
<ul>
<li><code>dispatch_semaphore_create(1);</code>  会创建一个指定数字的信号量，这里是1。</li>
<li><code>dispatch_semaphore_wait</code> 函数当信号量 &gt;= 1时会把信号量-1，并返回函数 。否则则会一直卡在此处，或者等到超时。</li>
<li><code>dispatch_semaphore_signal</code> 发送一个信号，让信号量+1。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</div><div class="line">NSMutableArray *marr = [NSMutableArray array];</div><div class="line">for (int i=0; i &lt; 9999; ++i) &#123;</div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">        [marr addObject:[NSNumber numberWithInt:i]];</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 上面例子执行完后，marr 里会包含 9999个 NSNumber 对象。因为通过 Dispatch Semaphore 控制始终只有一个线程在操作 marr。所以没有数据竞争的问题</div></pre></td></tr></table></figure>
<h1 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend / dispatch_resume"></a>dispatch_suspend / dispatch_resume</h1><p>这两个函数可以控制 <strong>Dispatch Queue</strong> 暂停(suspend) 和 恢复(resume)。当 <code>dispatch_suspend(queue)</code> 执行时 <strong>queue</strong> 被暂停。已经加入到 <code>queue</code> 中的任务会继续执行。后面在再加入的任务会暂停，一直等到 <code>dispatch_resume(queue)</code> 被执行。看具体例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;io.tao.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">dispatch_async(queue, ^&#123; sleep(2); NSLog(@&quot;queue1&quot;); &#125;);</div><div class="line">dispatch_async(queue, ^&#123; NSLog(@&quot;queue2&quot;); &#125;);</div><div class="line"></div><div class="line">NSLog(@&quot;queue supend...&quot;);</div><div class="line">dispatch_suspend(queue);</div><div class="line">dispatch_async(queue, ^&#123; NSLog(@&quot;queue3&quot;); &#125;);</div><div class="line"></div><div class="line">sleep(8);</div><div class="line">NSLog(@&quot;queue resume...&quot;);</div><div class="line">dispatch_resume(queue);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 上面例子的控制台输出。注意每条 Log 的时间。刚好能证明上面的结论</div><div class="line">2017-02-23 16:30:19.829 OCGCD[28759:29155110] queue supend...</div><div class="line">2017-02-23 16:30:19.829 OCGCD[28759:29155170] queue2</div><div class="line">2017-02-23 16:30:21.889 OCGCD[28759:29155168] queue1</div><div class="line">2017-02-23 16:30:27.903 OCGCD[28759:29155110] queue resume...</div><div class="line">2017-02-23 16:30:27.904 OCGCD[28759:29155167] queue3</div></pre></td></tr></table></figure>
<h1 id="GCD-的内存管理"><a href="#GCD-的内存管理" class="headerlink" title="GCD 的内存管理"></a>GCD 的内存管理</h1><p>在 iOS6 or Mac OS X 10.8 以前 GCD 对象并没有纳入 <code>ARC</code> 管理范围。通过带 <code>dispatch_xxx_create</code> 创建的值都需开发者负责释放。<code>dispatch_retain</code> <code>dispatch_release</code> 。iOS6 or Mac OS X 10.8 之后使用的是  ARC 的话就不需要手动管理内存了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-GCD&quot;&gt;&lt;a href=&quot;#什么是-GCD&quot; class=&quot;headerlink&quot; title=&quot;什么是 GCD ?&quot;&gt;&lt;/a&gt;什么是 GCD ?&lt;/h1&gt;&lt;p&gt;&lt;code&gt;GCD&lt;/code&gt; 全称为 &lt;code&gt;Grand Central Dispa
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个十年的结束, 另一个开始</title>
    <link href="http://yoursite.com/2017/01/27/%E4%B8%80%E4%B8%AA%E5%8D%81%E5%B9%B4%E7%9A%84%E7%BB%93%E6%9D%9F,%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2017/01/27/一个十年的结束, 另一个开始/</id>
    <published>2017-01-27T15:57:52.000Z</published>
    <updated>2017-01-29T04:43:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>二零一七年农历新年晚上的的鞭炮吵的让我什么都不想做,  就开始写我人生的第一篇博客.  </p>
<p>2007那年我11岁, 懵懵懂懂的拥有了人生的第一台电脑, 到现在已经十年时间了.  十年感知上是一个超级漫长的时间.  我竟然浑浑噩噩的一晃而过了.  在那之前对电脑基本一无所知.  拿到它后我总是整天折腾它, 经常把弄坏了自己又不知道怎么办. 然后只能拿去联想售后去修. 以至于后来售后都认识我, 见到我去就会幽怨的讲一句”你又来啦”.  后来售后哥哥就教我怎么重装系统. 再碰到问题不行就重装系统. 也是这个时候在网上看到比尔盖茨, 心里就有了以后做技术的想法. 去买了&lt;网页三剑客&gt;和&lt; Photoshop &gt;在家吃灰. 至于原因, 后来我觉得因为比尔盖茨当时是世界首富(太功利, 不对). 虽然十年过去了, 但人家还是首富. 我还是默默无闻. </p>
<p>07年一直到我初中辍学的11年辍学技术上基本没有啥进展. 只是跟着最基础入门视频写了最简单的 C. 还有玩了下 Flash, Dreamwear 等一些软件. 玩的很浅. 也没有产生什么作品.  甚至对计算机的基本认知都还不够. 更多的时间花在了耍 QQ 空间, 点亮 QQ 图标去了. 那时候 QQ 空间样子几天一换. 花哨到浏览器打开都要几秒. QQ 图标点了好多好多排. 反正当时没有看到比我亮的多的. 一遍骂着麻花藤一遍玩他的游戏. 这几年学没学好, 玩没玩好, 傻没傻透.  一个人熬夜很多事想不通.</p>
<p>12年就去了合肥一个新华电脑学院去学软件开发(2年制). 进去就是打字打2,3个月. 然后几个好朋友就开始自学之旅. 没有听一点课. 本来一起学着 java. 都准备选 java 方向. 就我去选了.net 开发. 因为可以拿 C# 画 windows 的界面呀. 这对我来说是最直观的一个产品呀.  对, 我就他妈是个画界面的. 后来网上鼓吹移动开发(不是鼓吹, 是真的有前景, 但是大家当时完全是脱离行业的). 所以我看似有先见之明去一个人去自学 iOS 开发. 装虚拟机开发. 学也很狗屁. 没入行的自学感觉真的很难. (这种情况更好是报班学)</p>
<p>13年中在新华的课程没学完, 觉得这样下去也是荒废时间. 就再次辍学去上海找工作了.  好不容易进了一家公司. 老板让我去学 cocos2dx 做棋牌游戏. 我只能欣然接受. 当时我的想法就是有份工作就很开心了. 于是就天天熬夜, 经常通宵的边学边做.  没本事没有方法论. 只能做拼命三郎. 天天熬夜, 然后继续那工作下去了.  15年3月去北京开始真正做iOS开发, 16年因为公司原因. 跑到杭州工作.  16年11月公司倒闭, 欠薪跑路. 17年农历新年, 我在杭州写下这篇. </p>
<p>复盘和总结我接触电脑以来的十年. 有一个很好的开始. 一开始就决定从事 IT 行业. 但是中间的路却没有走好. 有太多原因:</p>
<ol>
<li>上学时对软件开发认识不够, 不知道要往哪走. 没有氛围, 一个人很孤独很难. 浪费很多时间</li>
<li>开始工作后为公司加班太多, 没有太多为自己考虑. 没有构建好自己的知识体系</li>
<li>基础学科英语,数学太差, 刚工作时没啥感觉, 现在越来越难受</li>
<li>自己自制力太差看似很累, 很忙. 但其实效率低下.</li>
<li>没有认真对待选择, 很多失败都是自己选择失误 — 躲避选择, 随波逐流, 太心急太肤浅. </li>
<li>不是计算专业出身, 对编程基础不够重视.  </li>
<li>学习不讲方法论. 最近看的&lt;如何高效学习&gt;受益良多</li>
</ol>
<p>问题大概就这么多, 有问题就必须要解决, 面对十年的结束和新的开始,  所以年三十在这里立个 flag:</p>
<ol>
<li>养成早起习惯, 无论节假日上不上班早上7点醒.</li>
<li>每周必须有一天完全离开电脑. 放松</li>
<li>看完买的一套英语语法书. 阅读英文文档要变成日常</li>
<li>看完&lt; TCP/IP 详解 &gt;的三本黑书 和 &lt; 算法4 &gt; 外加一本编译原理相关的书</li>
<li>至少撸出2个个人产品</li>
<li>每月至少码一篇原创的blog</li>
</ol>
<p>最后 @all 新年快乐,  家人健康, 幸福开心.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二零一七年农历新年晚上的的鞭炮吵的让我什么都不想做,  就开始写我人生的第一篇博客.  &lt;/p&gt;
&lt;p&gt;2007那年我11岁, 懵懵懂懂的拥有了人生的第一台电脑, 到现在已经十年时间了.  十年感知上是一个超级漫长的时间.  我竟然浑浑噩噩的一晃而过了.  在那之前对电脑基
    
    </summary>
    
    
  </entry>
  
</feed>
